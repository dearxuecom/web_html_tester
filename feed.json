{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "测试",
  "home_page_url": "https://www.dearxue.com/web_html_tester/",
  "feed_url": "https://www.dearxue.com/web_html_tester/feed.json",
  "description": "测试， 未经测试的代码，不值得一读",
  "items": [
    {
      "title": "Spring 测试",
      "url": "https://www.dearxue.com/web_html_tester/spring/001_spring_framework_test.html",
      "id": "https://www.dearxue.com/web_html_tester/spring/001_spring_framework_test.html",
      "content_html": "<p>Spring 一直是TDD(test-driven development)的积极倡导者；</p>\n<p>IOC 功能在一些场景下恰好可以增强这个实现， 让测试更轻松；</p>\n<p>有了 <code>Spring Framework Testing</code> 扩展，让单元测试(unit) + 集成测试(integration)更加容易和丝滑。</p>\n<div><pre><code><span>\\</span>---org\n    <span>\\</span>---springframework\n        +---mock\n        <span>|</span>   +---env\n        <span>|</span>   +---http\n        <span>|</span>   <span>|</span>   +---client\n        <span>|</span>   <span>|</span>   <span>|</span>   <span>\\</span>---reactive\n        <span>|</span>   <span>|</span>   <span>\\</span>---server\n        <span>|</span>   <span>|</span>       <span>\\</span>---reactive\n        <span>|</span>   <span>\\</span>---web\n        <span>|</span>       +---reactive\n        <span>|</span>       <span>|</span>   <span>\\</span>---function\n        <span>|</span>       <span>|</span>       <span>\\</span>---server\n        <span>|</span>       <span>\\</span>---server\n        <span>\\</span>---test\n            +---annotation\n            +---context\n            <span>|</span>   +---cache\n            <span>|</span>   +---event\n            <span>|</span>   <span>|</span>   <span>\\</span>---annotation\n            <span>|</span>   +---jdbc\n            <span>|</span>   +---junit\n            <span>|</span>   <span>|</span>   <span>\\</span>---jupiter\n            <span>|</span>   <span>|</span>       <span>\\</span>---web\n            <span>|</span>   +---junit4\n            <span>|</span>   <span>|</span>   +---rules\n            <span>|</span>   <span>|</span>   <span>\\</span>---statements\n            <span>|</span>   +---support\n            <span>|</span>   +---testng\n            <span>|</span>   +---transaction\n            <span>|</span>   +---util\n            <span>|</span>   <span>\\</span>---web\n            <span>|</span>       <span>\\</span>---socket\n            +---jdbc\n            +---util\n            <span>\\</span>---web\n                +---client\n                <span>|</span>   +---match\n                <span>|</span>   <span>\\</span>---response\n                +---reactive\n                <span>|</span>   <span>\\</span>---server\n                <span>\\</span>---servlet\n                    +---client\n                    +---htmlunit\n                    <span>|</span>   <span>\\</span>---webdriver\n                    +---request\n                    +---result\n                    <span>\\</span>---setup\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>整体的分包结构， 其实也是整个 <code>Spring Framework Testing</code>架构, 上面的代码结构也基本切合官方的文档结构 <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Testing</a>。</p>\n<div><pre><code>\n<span>1.</span> <span>Introduction</span> <span>to</span> <span>Spring</span> <span>Testing</span>\n<span>2.</span> <span>Unit</span> <span>Testing</span>  <span>[</span><span>0</span><span>]</span> 都是辅助的\n   <span>2.1</span><span>.</span> <span>Mock</span> <span>Objects</span>\n      <span>2.1</span><span>.1</span><span>.</span> <span>Environment</span>\n      <span>2.1</span><span>.2</span><span>.</span> JNDI\n      <span>2.1</span><span>.3</span><span>.</span> <span>Servlet</span> API\n      <span>2.1</span><span>.4</span><span>.</span> <span>Spring</span> <span>Web</span> <span>Reactive</span>\n   <span>2.2</span><span>.</span> <span>Unit</span> <span>Testing</span> <span>Support</span> <span>Classes</span>\n      <span>2.2</span><span>.1</span><span>.</span> <span>General</span> <span>Testing</span> <span>Utilities</span>\n      <span>2.2</span><span>.2</span><span>.</span> <span>Spring</span> MVC <span>Testing</span> <span>Utilities</span>\n<span>3.</span> <span>Integration</span> <span>Testing</span>\n   <span>3.1</span><span>.</span> <span>Overview</span>\n   <span>3.2</span><span>.</span> <span>Goals</span> of <span>Integration</span> <span>Testing</span> <span>[</span><span>1</span><span>]</span> 理解为什么集成测试\n      <span>3.2</span><span>.1</span><span>.</span> <span>Context</span> <span>Management</span> and <span>Caching</span>\n      <span>3.2</span><span>.2</span><span>.</span> <span>Dependency</span> <span>Injection</span> of <span>Test</span> <span>Fixtures</span>\n      <span>3.2</span><span>.3</span><span>.</span> <span>Transaction</span> <span>Management</span>\n      <span>3.2</span><span>.4</span><span>.</span> <span>Support</span> <span>Classes</span> <span>for</span> <span>Integration</span> <span>Testing</span>\n   <span>3.3</span><span>.</span> JDBC <span>Testing</span> <span>Support</span>\n   <span>3.4</span><span>.</span> <span>Annotations</span>   <span>[</span><span>3</span><span>]</span> 重点， 重点了解下 <span>Jupiter</span> <span>Junit5</span>的操作方式\n      <span>3.4</span><span>.1</span><span>.</span> <span>Spring</span> <span>Testing</span> <span>Annotations</span>\n      <span>3.4</span><span>.2</span><span>.</span> <span>Standard</span> <span>Annotation</span> <span>Support</span>\n      <span>3.4</span><span>.3</span><span>.</span> <span>Spring</span> <span>JUnit</span> <span>4</span> <span>Testing</span> <span>Annotations</span>\n      <span>3.4</span><span>.4</span><span>.</span> <span>Spring</span> <span>JUnit</span> <span>Jupiter</span> <span>Testing</span> <span>Annotations</span>\n      <span>3.4</span><span>.5</span><span>.</span> <span>Meta</span><span>-</span><span>Annotation</span> <span>Support</span> <span>for</span> <span>Testing</span>\n   <span>3.5</span><span>.</span> <span>Spring</span> <span>TestContext</span> <span>Framework</span> <span>[</span><span>4</span><span>]</span> 核心，相当于设计一个 <span>Spring</span> 容器\n      <span>3.5</span><span>.1</span><span>.</span> <span>Key</span> <span>Abstractions</span>\n      <span>3.5</span><span>.2</span><span>.</span> <span>Bootstrapping</span> the <span>TestContext</span> <span>Framework</span>\n      <span>3.5</span><span>.3</span><span>.</span> <span>TestExecutionListener</span> <span>Configuration</span>\n      <span>3.5</span><span>.4</span><span>.</span> <span>Application</span> <span>Events</span>\n      <span>3.5</span><span>.5</span><span>.</span> <span>Test</span> <span>Execution</span> <span>Events</span>\n      <span>3.5</span><span>.7</span><span>.</span> <span>Dependency</span> <span>Injection</span> of <span>Test</span> <span>Fixtures</span>\n      <span>3.5</span><span>.8</span><span>.</span> <span>Testing</span> <span>Request</span><span>-</span> and <span>Session</span><span>-</span>scoped <span>Beans</span>\n      <span>3.5</span><span>.9</span><span>.</span> <span>Transaction</span> <span>Management</span>\n      <span>3.5</span><span>.10</span><span>.</span> <span>Executing</span> SQL <span>Scripts</span>\n      <span>3.5</span><span>.11</span><span>.</span> <span>Parallel</span> <span>Test</span> <span>Execution</span>\n      <span>3.5</span><span>.12</span><span>.</span> <span>TestContext</span> <span>Framework</span> <span>Support</span> <span>Classes</span>\n   <span>3.6</span><span>.</span> <span>WebTestClient</span>  <span>[</span><span>5</span><span>]</span> MVC 重点关注，这个一下内容\n      <span>3.6</span><span>.1</span><span>.</span> <span>Setup</span>\n      <span>3.6</span><span>.2</span><span>.</span> <span>Writing</span> <span>Tests</span>\n   <span>3.7</span><span>.</span> <span>MockMvc</span>\n      <span>3.7</span><span>.1</span><span>.</span> <span>Overview</span>\n      <span>3.7</span><span>.2</span><span>.</span> <span>HtmlUnit</span> <span>Integration</span>\n   <span>3.8</span><span>.</span> <span>Testing</span> <span>Client</span> <span>Applications</span>\n      <span>3.8</span><span>.1</span><span>.</span> <span>Static</span> <span>Imports</span>\n      <span>3.8</span><span>.2</span><span>.</span> <span>Further</span> <span>Examples</span> of <span>Client</span><span>-</span>side REST <span>Tests</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src=\"/images/Spring-test-arch.png\" alt=\"Spring 测试框架\" loading=\"lazy\"></p>\n<h2 id=\"单元测试\" tabindex=\"-1\"> 单元测试</h2>\n<ol>\n<li>分层测试</li>\n<li>Mock 隔离层级之间的依赖</li>\n</ol>\n<p>Mock 的有：</p>\n<ol>\n<li>Environment  <code>org.springframework.mock.env</code></li>\n<li>JNDI  <code>暂不展开，使用比较少</code></li>\n<li>Servlet API  <code>org.springframework.mock.web</code></li>\n<li>Spring Web Reactived  <code>org.springframework.mock.http.server.reactive</code></li>\n</ol>\n<p>单元测试支撑类</p>\n<ol>\n<li>测试辅助类  <code>AopProxyUtils</code></li>\n<li>MVC 测试辅助 <code> ModelAndViewAssert</code></li>\n</ol>\n<h2 id=\"集成测试\" tabindex=\"-1\"> 集成测试</h2>\n<p>避免部署到服务环境下的集成测试， 会大大加快集成测试的效率和速度， 集成测试可以：</p>\n<ol>\n<li>IOC 装配是否正常</li>\n<li>中间件： JDBC/ORM， SQL 语法， JPA/My batis /Hibernate 是否正常</li>\n</ol>\n<p><code>spring-test</code>  不需要启动服务器容器（tomcat/jetty）， 测试虽然比单元测试慢， 但是比Selenium 模拟 e2e 测试还是快很多。</p>\n<ol>\n<li>IOC 容器管理和缓存\n<ol>\n<li>ApplicationContext</li>\n<li>WebApplicationContext</li>\n</ol>\n</li>\n<li>依赖注入, 测试实例\n<ol>\n<li>TestContext</li>\n</ol>\n</li>\n<li>事务管理\n<ol>\n<li>PlatformTransactionManager, 默认事务回滚， 包装测试上下文干净</li>\n</ol>\n</li>\n<li>Spring 其他基础类\n<ol>\n<li>预准备的 abstract 测试骨架类， 比如ApplicationContext， 或者数据测试的 JdbcTemplate</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"annotation\" tabindex=\"-1\"> Annotation</h3>\n<ol>\n<li>Spring Testing Annotations</li>\n<li>Standard Annotation Support</li>\n<li>Spring JUnit Jupiter Testing Annotations, Junit 4 忽略</li>\n<li>Meta-Annotation Support for Testing</li>\n</ol>\n<h4 id=\"专门测试设的annotation\" tabindex=\"-1\"> 专门测试设的Annotation</h4>\n<p>几个重点：</p>\n<ol>\n<li>@ContextConfiguration</li>\n<li>@WebAppConfiguration</li>\n<li>@ActiveProfiles</li>\n<li>@DynamicPropertySource</li>\n<li>@DirtiesContext</li>\n</ol>\n<h4 id=\"标准\" tabindex=\"-1\"> 标准</h4>\n<p>Spring 标准的 @Autowired  @Qualifier  等等</p>\n<h2 id=\"实战\" tabindex=\"-1\"> 实战</h2>\n<p><a href=\"https://github.com/spring-projects/spring-framework/tree/main/spring-test\" target=\"_blank\" rel=\"noopener noreferrer\">spring-test 源码</a>  &amp; <a href=\"https://github.com/spring-projects/spring-framework/tree/main/spring-test/src/main/java/org/springframework/test/context/junit/jupiter\" target=\"_blank\" rel=\"noopener noreferrer\">Jupiter5 扩展</a> 重点： <code>SpringExtension</code> &amp;  <code>SpringJUnitConfig</code></p>\n<p><a href=\"https://gitee.com/dearxuecom/better_test/tree/master/005_spring_junit5_raw\" target=\"_blank\" rel=\"noopener noreferrer\">005_spring_junit5_raw</a> &amp; <a href=\"https://gitee.com/dearxuecom/better_test/tree/master/005_spring_junit5_new\" target=\"_blank\" rel=\"noopener noreferrer\">005_spring_junit5_new</a> 测试例子。</p>\n<div><pre><code>\n<span>//运行Classpath</span>\nruntimeClasspath <span>-</span> Runtime classpath of source set <span>'main'</span><span>.</span>\n<span>+</span><span>--</span><span>-</span> org<span>.</span>apache<span>.</span>logging<span>.</span>log4j<span>:</span>log4j<span>-</span>core<span>:</span><span>2.17</span><span>.</span><span>1</span>\n<span>|</span>    \\<span>--</span><span>-</span> org<span>.</span>apache<span>.</span>logging<span>.</span>log4j<span>:</span>log4j<span>-</span>api<span>:</span><span>2.17</span><span>.</span><span>1</span>\n\\<span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>context<span>:</span><span>5.3</span><span>.</span><span>20</span>\n     <span>+</span><span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>aop<span>:</span><span>5.3</span><span>.</span><span>20</span>\n     <span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>beans<span>:</span><span>5.3</span><span>.</span><span>20</span>\n     <span>|</span>    <span>|</span>    \\<span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>core<span>:</span><span>5.3</span><span>.</span><span>20</span>\n     <span>|</span>    <span>|</span>         \\<span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>jcl<span>:</span><span>5.3</span><span>.</span><span>20</span>\n     <span>|</span>    \\<span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>core<span>:</span><span>5.3</span><span>.</span><span>20</span> <span>(</span><span>*</span><span>)</span>\n     <span>+</span><span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>beans<span>:</span><span>5.3</span><span>.</span><span>20</span> <span>(</span><span>*</span><span>)</span>\n     <span>+</span><span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>core<span>:</span><span>5.3</span><span>.</span><span>20</span> <span>(</span><span>*</span><span>)</span>\n     \\<span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>expression<span>:</span><span>5.3</span><span>.</span><span>20</span>\n          \\<span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>core<span>:</span><span>5.3</span><span>.</span><span>20</span> <span>(</span><span>*</span><span>)</span>\n\n<span>//测试Classpath</span>\ntestRuntimeClasspath <span>-</span> Runtime classpath of source set <span>'test'</span><span>.</span>\n<span>+</span><span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>test<span>:</span><span>5.3</span><span>.</span><span>20</span>\n<span>|</span>    \\<span>--</span><span>-</span> org<span>.</span>springframework<span>:</span>spring<span>-</span>core<span>:</span><span>5.3</span><span>.</span><span>20</span> <span>(</span><span>*</span><span>)</span>\n<span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>:</span>junit<span>-</span>bom<span>:</span><span>5.8</span><span>.</span><span>2</span>\n<span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter<span>:</span><span>5.8</span><span>.</span><span>2</span> <span>(</span>c<span>)</span>\n<span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter<span>-</span>api<span>:</span><span>5.8</span><span>.</span><span>2</span> <span>(</span>c<span>)</span>\n<span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter<span>-</span>engine<span>:</span><span>5.8</span><span>.</span><span>2</span> <span>(</span>c<span>)</span>\n<span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>platform<span>:</span>junit<span>-</span>platform<span>-</span>launcher<span>:</span><span>1.8</span><span>.</span><span>2</span> <span>(</span>c<span>)</span>\n<span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter<span>-</span>params<span>:</span><span>5.8</span><span>.</span><span>2</span> <span>(</span>c<span>)</span>\n<span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>platform<span>:</span>junit<span>-</span>platform<span>-</span>commons<span>:</span><span>1.8</span><span>.</span><span>2</span> <span>(</span>c<span>)</span>\n<span>|</span>    \\<span>--</span><span>-</span> org<span>.</span>junit<span>.</span>platform<span>:</span>junit<span>-</span>platform<span>-</span>engine<span>:</span><span>1.8</span><span>.</span><span>2</span> <span>(</span>c<span>)</span>\n<span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter <span>-></span> <span>5.8</span><span>.</span><span>2</span>\n<span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter<span>-</span>api<span>:</span><span>5.8</span><span>.</span><span>2</span>\n<span>|</span>    <span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>opentest4j<span>:</span>opentest4j<span>:</span><span>1.2</span><span>.</span><span>0</span>\n<span>|</span>    <span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>platform<span>:</span>junit<span>-</span>platform<span>-</span>commons<span>:</span><span>1.8</span><span>.</span><span>2</span>\n<span>|</span>    <span>|</span>    <span>|</span>    \\<span>--</span><span>-</span> org<span>.</span>apiguardian<span>:</span>apiguardian<span>-</span>api<span>:</span><span>1.1</span><span>.</span><span>2</span>\n<span>|</span>    <span>|</span>    \\<span>--</span><span>-</span> org<span>.</span>apiguardian<span>:</span>apiguardian<span>-</span>api<span>:</span><span>1.1</span><span>.</span><span>2</span>\n<span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter<span>-</span>params<span>:</span><span>5.8</span><span>.</span><span>2</span>\n<span>|</span>    <span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter<span>-</span>api<span>:</span><span>5.8</span><span>.</span><span>2</span> <span>(</span><span>*</span><span>)</span>\n<span>|</span>    <span>|</span>    \\<span>--</span><span>-</span> org<span>.</span>apiguardian<span>:</span>apiguardian<span>-</span>api<span>:</span><span>1.1</span><span>.</span><span>2</span>\n<span>|</span>    \\<span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter<span>-</span>engine<span>:</span><span>5.8</span><span>.</span><span>2</span>\n<span>|</span>         <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>platform<span>:</span>junit<span>-</span>platform<span>-</span>engine<span>:</span><span>1.8</span><span>.</span><span>2</span>\n<span>|</span>         <span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>opentest4j<span>:</span>opentest4j<span>:</span><span>1.2</span><span>.</span><span>0</span>\n<span>|</span>         <span>|</span>    <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>platform<span>:</span>junit<span>-</span>platform<span>-</span>commons<span>:</span><span>1.8</span><span>.</span><span>2</span> <span>(</span><span>*</span><span>)</span>\n<span>|</span>         <span>|</span>    \\<span>--</span><span>-</span> org<span>.</span>apiguardian<span>:</span>apiguardian<span>-</span>api<span>:</span><span>1.1</span><span>.</span><span>2</span>\n<span>|</span>         <span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter<span>-</span>api<span>:</span><span>5.8</span><span>.</span><span>2</span> <span>(</span><span>*</span><span>)</span>\n<span>|</span>         \\<span>--</span><span>-</span> org<span>.</span>apiguardian<span>:</span>apiguardian<span>-</span>api<span>:</span><span>1.1</span><span>.</span><span>2</span>\n<span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter<span>-</span>api <span>-></span> <span>5.8</span><span>.</span><span>2</span> <span>(</span><span>*</span><span>)</span>\n<span>+</span><span>--</span><span>-</span> org<span>.</span>junit<span>.</span>jupiter<span>:</span>junit<span>-</span>jupiter<span>-</span>engine <span>-></span> <span>5.8</span><span>.</span><span>2</span> <span>(</span><span>*</span><span>)</span>\n\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"上下文\" tabindex=\"-1\"> 上下文</h3>\n<p><code>@ContextConfiguration</code>  注入和启动上下文。</p>\n<div><pre><code><span>@ExtendWith</span><span>(</span><span>SpringExtension</span><span>.</span><span>class</span><span>)</span>\n<span>@ContextConfiguration</span><span>(</span><span>\"classpath:application-context.xml\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>SpringAppTest</span> <span>{</span>\n\n  <span>@Autowired</span> <span>private</span> <span>Passenger</span> passenger<span>;</span>\n  <span>private</span> <span>Passenger</span> expectedPassenger<span>;</span>\n\n  <span>@BeforeEach</span>\n  <span>public</span> <span>void</span> <span>setUp</span><span>(</span><span>)</span> <span>{</span>\n    expectedPassenger <span>=</span> <span>getExpectedPassenger</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Test</span>\n  <span>public</span> <span>void</span> <span>testInitPassenger</span><span>(</span><span>)</span> <span>{</span>\n    <span>assertEquals</span><span>(</span>expectedPassenger<span>,</span> passenger<span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>passenger<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>SpringExtension</code> 做了Junit5 上的扩展， 参考 <a href=\"/junit/005_junit_extend.html\">Junit 扩展</a></p>\n<div><pre><code>\n<span>public</span> <span>class</span> <span>SpringExtension</span> \n<span>implements</span> \n\n   <span>BeforeAllCallback</span><span>,</span> \n   <span>AfterAllCallback</span><span>,</span> \n   <span>TestInstancePostProcessor</span><span>,</span>\n   <span>BeforeEachCallback</span><span>,</span> \n   <span>AfterEachCallback</span><span>,</span> \n   <span>BeforeTestExecutionCallback</span><span>,</span> \n   <span>AfterTestExecutionCallback</span><span>,</span>\n   <span>ParameterResolver</span> <span>{</span>\n\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"高级点\" tabindex=\"-1\"> 高级点</h3>\n<p><a href=\"https://github.com/spring-projects/spring-framework/tree/main/spring-test/src/test/java/org/springframework/test/context/junit/jupiter\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/spring-projects/spring-framework/tree/main/spring-test/src/test/java/org/springframework/test/context/junit/jupiter</a></p>\n<ol>\n<li>Mockito.mock() vs @Mock vs @MockBean</li>\n<li>A Quick Guide to @TestPropertySource</li>\n<li>Guide to ReflectionTestUtils for Unit Testing</li>\n<li>How to Test the @Scheduled Annotation</li>\n<li>Using SpringJUnit4ClassRunner with Parameterized</li>\n<li>Override Properties in Spring’s Tests</li>\n<li>A Quick Guide to @DirtiesContext</li>\n</ol>\n<p>SpringJUnitConfig\nSpringJUnitWebConfig</p>\n<h2 id=\"资源\" tabindex=\"-1\"> 资源</h2>\n<p>Spring testing 涉及到的第三方资源:</p>\n<ol>\n<li>JUnit: “A programmer-friendly testing framework for Java”. Used by the Spring Framework in its test suite and supported in the Spring TestContext Framework.</li>\n<li>TestNG: A testing framework inspired by JUnit with added support for test groups, data-driven testing, distributed testing, and other features. Supported in the Spring TestContext Framework</li>\n<li>AssertJ: “Fluent assertions for Java”, including support for Java 8 lambdas, streams, and other features.</li>\n<li>Mock Objects: Article in Wikipedia.</li>\n<li><a href=\"http://MockObjects.com\" target=\"_blank\" rel=\"noopener noreferrer\">MockObjects.com</a>: Web site dedicated to mock objects, a technique for improving the design of code within test-driven development.</li>\n<li>Mockito: Java mock library based on the Test Spy pattern. Used by the Spring Framework in its test suite.</li>\n</ol>\n<p>EasyMock: Java library “that provides Mock Objects for interfaces (and objects through the class extension) by generating them on the fly using Java’s proxy mechanism.”</p>\n<p>JMock: Library that supports test-driven development of Java code with mock objects.</p>\n<p>DbUnit: JUnit extension (also usable with Ant and Maven) that is targeted at database-driven projects and, among other things, puts your database into a known state between test runs.</p>\n<p>Testcontainers: Java library that supports JUnit tests, providing lightweight, throwaway instances of common databases, Selenium web browsers, or anything else that can run in a Docker container.</p>\n<p>The Grinder: Java load testing framework.</p>\n<p>SpringMockK: Support for Spring Boot integration tests written in Kotlin using MockK instead of Mockito.</p>\n<h2 id=\"参考\" tabindex=\"-1\"> 参考</h2>\n<ol start=\"3\">\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Testing</a></li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/\" target=\"_blank\" rel=\"noopener noreferrer\">Spring 源码</a></li>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#appendix.dependency-versions.coordinates\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot 版本</a></li>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot Testing</a></li>\n<li><a href=\"https://github.com/spring-projects/spring-boot/\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot 源码</a></li>\n<li><a href=\"https://github.com/spring-guides/gs-testing-web\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Guid Web Test Code</a></li>\n<li><a href=\"https://spring.io/guides/gs/testing-web/\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Guid Web Test</a></li>\n<li><a href=\"https://www.baeldung.com/category/testing/\" target=\"_blank\" rel=\"noopener noreferrer\">Baeldung Test</a></li>\n<li><a href=\"https://www.baeldung.com/spring-boot-testing\" target=\"_blank\" rel=\"noopener noreferrer\">Baeldung Spring boot test</a></li>\n</ol>\n",
      "image": "https://www.dearxue.com/web_html_tester/images/Spring-test-arch.png",
      "date_published": "2022-06-30T01:34:42.000Z",
      "date_modified": "2022-06-30T01:34:42.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Spring 依赖",
      "url": "https://www.dearxue.com/web_html_tester/spring/002_spring_boot_test_base.html",
      "id": "https://www.dearxue.com/web_html_tester/spring/002_spring_boot_test_base.html",
      "content_html": "<p><a href=\"https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-starters/spring-boot-starter-test/build.gradle\" target=\"_blank\" rel=\"noopener noreferrer\">gradle depedency</a></p>\n<div><pre><code>dependencies {\n\tapi(project(&quot;:spring-boot-project:spring-boot-starters:spring-boot-starter&quot;))\n\tapi(project(&quot;:spring-boot-project:spring-boot-test&quot;))\n\tapi(project(&quot;:spring-boot-project:spring-boot-test-autoconfigure&quot;))\n\tapi(&quot;com.jayway.jsonpath:json-path&quot;)\n\tapi(&quot;jakarta.xml.bind:jakarta.xml.bind-api&quot;)\n\tapi(&quot;org.assertj:assertj-core&quot;)\n\tapi(&quot;org.hamcrest:hamcrest&quot;)\n\tapi(&quot;org.junit.jupiter:junit-jupiter&quot;)\n\tapi(&quot;org.mockito:mockito-core&quot;)\n\tapi(&quot;org.mockito:mockito-junit-jupiter&quot;)\n\tapi(&quot;org.skyscreamer:jsonassert&quot;)\n\tapi(&quot;org.springframework:spring-core&quot;)\n\tapi(&quot;org.springframework:spring-test&quot;)\n\tapi(&quot;org.xmlunit:xmlunit-core&quot;) {\n\t\texclude group: &quot;javax.xml.bind&quot;, module: &quot;jaxb-api&quot;\n\t}\n}\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"spring-boot-测试项目结构\" tabindex=\"-1\"> Spring boot 测试项目结构</h3>\n<p>如果把整个 spring boot 测试相关的项目捋一下会有这么多：</p>\n<ol>\n<li><strong>[4-spring-boot-test]</strong> &amp;&amp; <strong>[5-spring-boot-test-autoconfigure]</strong>\n<ol>\n<li>spring-boot-test 包含核心的测试扩展</li>\n<li>spring-boot-test-autoconfigure 测试里面支持  auto-configuration</li>\n</ol>\n</li>\n<li>[9-10] spring 自己框架的冒烟测试</li>\n</ol>\n<div><pre><code>\n+---spring-boot-project\n<span>|</span>   +---spring-boot-parent\n<span>|</span>   +---spring-boot-starters\n<span>|</span>   <span>|</span>   +---spring-boot-starter        <span>[</span><span>1</span><span>]</span>\n<span>|</span>   <span>|</span>   +---spring-boot-starter-parent <span>[</span><span>2</span><span>]</span>\n<span>|</span>   <span>|</span>   +---spring-boot-starter-test   <span>[</span><span>3</span><span>]</span> \n<span>|</span>   +---spring-boot-test               <span>[</span><span>4</span><span>]</span> \n<span>|</span>   +---spring-boot-test-autoconfigure <span>[</span><span>5</span><span>]</span>\n<span>|</span>   +---spring-boot-tools              <span>[</span><span>6</span><span>]</span>\n<span>|</span>       <span>\\</span>---spring-boot-test-support   <span>[</span><span>7</span><span>]</span>\n+---spring-boot-system-tests           <span>[</span><span>8</span><span>]</span>\n<span>|</span>   +---spring-boot-deployment-tests\n<span>|</span>   <span>\\</span>---spring-boot-image-tests\n+---spring-boot-tests                  <span>[</span><span>9</span><span>]</span>\n<span>|</span>   +---spring-boot-deployment-tests  \n<span>|</span>   +---spring-boot-integration-tests \n<span>|</span>   <span>|</span>   +---spring-boot-configuration-processor-tests\n<span>|</span>   <span>|</span>   +---spring-boot-launch-script-tests\n<span>|</span>   <span>|</span>   +---spring-boot-loader-tests\n<span>|</span>   <span>|</span>   <span>\\</span>---spring-boot-server-tests\n<span>|</span>   <span>\\</span>---spring-boot-smoke-tests        <span>[</span><span>10</span><span>]</span>\n<span>|</span>       +---spring-boot-smoke-test-actuator\n<span>|</span>       +---spring-boot-smoke-test-actuator-custom-security\n<span>|</span>       +---spring-boot-smoke-test-actuator-log4j2\n<span>|</span>       +---spring-boot-smoke-test-actuator-noweb\n<span>|</span>       +---spring-boot-smoke-test-actuator-ui\n<span>|</span>       +---spring-boot-smoke-test-amqp\n<span>|</span>       +---spring-boot-smoke-test-animated-banner\n<span>|</span>       +---spring-boot-smoke-test-ant\n<span>|</span>       +---spring-boot-smoke-test-aop\n<span>|</span>       +---spring-boot-smoke-test-batch\n<span>|</span>       +---spring-boot-smoke-test-bootstrap-registry\n<span>|</span>       +---spring-boot-smoke-test-cache\n<span>|</span>       +---spring-boot-smoke-test-data-jdbc\n<span>|</span>       +---spring-boot-smoke-test-data-jpa\n<span>|</span>       +---spring-boot-smoke-test-data-ldap\n<span>|</span>       +---spring-boot-smoke-test-data-r2dbc\n<span>|</span>       +---spring-boot-smoke-test-data-r2dbc-flyway\n<span>|</span>       +---spring-boot-smoke-test-data-r2dbc-liquibase\n<span>|</span>       +---spring-boot-smoke-test-data-rest\n<span>|</span>       +---spring-boot-smoke-test-devtools\n<span>|</span>       +---spring-boot-smoke-test-flyway\n<span>|</span>       +---spring-boot-smoke-test-hateoas\n<span>|</span>       +---spring-boot-smoke-test-integration\n<span>|</span>       +---spring-boot-smoke-test-jetty\n<span>|</span>       +---spring-boot-smoke-test-jetty-jsp\n<span>|</span>       +---spring-boot-smoke-test-jetty-ssl\n<span>|</span>       +---spring-boot-smoke-test-jpa\n<span>|</span>       +---spring-boot-smoke-test-junit-vintage\n<span>|</span>       +---spring-boot-smoke-test-kafka\n<span>|</span>       +---spring-boot-smoke-test-liquibase\n<span>|</span>       +---spring-boot-smoke-test-logback\n<span>|</span>       +---spring-boot-smoke-test-oauth2-client\n<span>|</span>       +---spring-boot-smoke-test-oauth2-resource-server\n<span>|</span>       +---spring-boot-smoke-test-parent-context\n<span>|</span>       +---spring-boot-smoke-test-profile\n<span>|</span>       +---spring-boot-smoke-test-property-validation\n<span>|</span>       +---spring-boot-smoke-test-quartz\n<span>|</span>       +---spring-boot-smoke-test-reactive-oauth2-client\n<span>|</span>       +---spring-boot-smoke-test-reactive-oauth2-resource-server\n<span>|</span>       +---spring-boot-smoke-test-rsocket\n<span>|</span>       +---spring-boot-smoke-test-saml2-service-provider\n<span>|</span>       +---spring-boot-smoke-test-secure\n<span>|</span>       +---spring-boot-smoke-test-secure-webflux\n<span>|</span>       +---spring-boot-smoke-test-servlet\n<span>|</span>       +---spring-boot-smoke-test-session-hazelcast\n<span>|</span>       +---spring-boot-smoke-test-session-jdbc\n<span>|</span>       +---spring-boot-smoke-test-session-mongo\n<span>|</span>       +---spring-boot-smoke-test-session-redis\n<span>|</span>       +---spring-boot-smoke-test-session-webflux-mongo\n<span>|</span>       +---spring-boot-smoke-test-session-webflux-redis\n<span>|</span>       +---spring-boot-smoke-test-test-nomockito\n<span>|</span>       +---spring-boot-smoke-test-testng\n<span>|</span>       +---spring-boot-smoke-test-tomcat\n<span>|</span>       +---spring-boot-smoke-test-tomcat-jsp\n<span>|</span>       +---spring-boot-smoke-test-tomcat-multi-connectors\n<span>|</span>       +---spring-boot-smoke-test-tomcat-ssl\n<span>|</span>       +---spring-boot-smoke-test-traditional\n<span>|</span>       +---spring-boot-smoke-test-undertow\n<span>|</span>       +---spring-boot-smoke-test-undertow-ssl\n<span>|</span>       +---spring-boot-smoke-test-war\n<span>|</span>       +---spring-boot-smoke-test-web-application-type\n<span>|</span>       +---spring-boot-smoke-test-web-freemarker\n<span>|</span>       +---spring-boot-smoke-test-web-groovy-templates\n<span>|</span>       +---spring-boot-smoke-test-web-jsp\n<span>|</span>       +---spring-boot-smoke-test-web-method-security\n<span>|</span>       +---spring-boot-smoke-test-web-mustache\n<span>|</span>       +---spring-boot-smoke-test-web-secure\n<span>|</span>       +---spring-boot-smoke-test-web-secure-custom\n<span>|</span>       +---spring-boot-smoke-test-web-secure-jdbc\n<span>|</span>       +---spring-boot-smoke-test-web-static\n<span>|</span>       +---spring-boot-smoke-test-web-thymeleaf\n<span>|</span>       +---spring-boot-smoke-test-webflux\n<span>|</span>       +---spring-boot-smoke-test-webflux-coroutines\n<span>|</span>       +---spring-boot-smoke-test-webservices\n<span>|</span>       +---spring-boot-smoke-test-websocket-jetty\n<span>|</span>       +---spring-boot-smoke-test-websocket-tomcat\n<span>|</span>       +---spring-boot-smoke-test-websocket-undertow\n<span>|</span>       <span>\\</span>---spring-boot-smoke-test-xml\n\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"参考资料\" tabindex=\"-1\"> 参考资料</h2>\n<ol>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#appendix.dependency-versions.coordinates\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot 版本</a></li>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot Testing</a></li>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Testing</a></li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/\" target=\"_blank\" rel=\"noopener noreferrer\">Spring 源码</a></li>\n<li><a href=\"https://github.com/spring-projects/spring-boot/\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot 源码</a></li>\n</ol>\n",
      "date_published": "2022-06-30T01:34:42.000Z",
      "date_modified": "2022-06-30T01:34:42.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Junit 扩展",
      "url": "https://www.dearxue.com/web_html_tester/junit/005_junit_extend.html",
      "id": "https://www.dearxue.com/web_html_tester/junit/005_junit_extend.html",
      "content_html": "<p>这里涉及到 Junit5  更深内容 <a href=\"https://junit.org/junit5/docs/current/user-guide/#extensions\" target=\"_blank\" rel=\"noopener noreferrer\">Extension Model</a>;</p>\n<p>在 Junit4 中有， Runner, TestRule, &amp; MethodRule 扩展点， 在Junit 5中归一为 API Extension ， 不过这也仅仅是个 marker interface。</p>\n<p><a href=\"https://github.com/spring-projects/spring-framework/tree/main/spring-test/src/main/java/org/springframework/test/context/junit4\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Test Junit4 Extenstion</a> vs <a href=\"https://github.com/spring-projects/spring-framework/tree/main/spring-test/src/main/java/org/springframework/test/context/junit/jupiter\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Test Jupiter Extenstion</a>, 两个正好体现 Junit 4&amp;5 之间的差别。</p>\n<p><strong>Junit4</strong> 的扩展局限性:</p>\n<ol>\n<li>必须在测试类级别上使用 <code>@RunWith</code> 注解来声明 <code>Runner</code> 。</li>\n<li><code>@RunWith</code> 仅接受一个参数： <code>Runner</code> 的实现类。因为每个测试类最多只能拥有一个 <code>Runner</code> ，所以每个测试类最多也只能拥有一个扩展点。(在PowerMock中引入了 <code>@PowerMockRunnerDelegate</code>,可以同时使用两个Runner)</li>\n<li>为了解决 Runner 的限制，JUnit 4.7 引入了 <code>@Rule</code> 。一个测试类可声明多个 <code>@Rule</code> ，这些规则可在类级别和测试方法级别上运行，但是它只能在测试运行之前或之后执行指定操作。如果我们想在此之外的时间点进行扩展，<code>@Rule</code>也无法满足我们的要求。</li>\n</ol>\n<p>JUnit 5扩展机制的核心准则: <code>Prefer extension points over features</code>; 基于这一准则，JUnit 5 中定义了许多扩展点，每个扩展点都对应一个接口。我们可以定义自己的扩展可以实现其中的某些接口，然后通过 <code>@ExtendWith</code> 注解注册给 JUnit，后者会在特定的时间点调用注册的接口实现。</p>\n<p>JUnit5 定义的部分扩展点:</p>\n<table>\n<thead>\n<tr>\n<th>接口</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BeforeAllCallback</td>\n<td>在所有测试方法执行前定义测试容器执行的行为，也就是在 @BeforeAll 注解的方法之前执行</td>\n</tr>\n<tr>\n<td>AfterAllCallback</td>\n<td>在@AfterAll 注解的方法之后执行</td>\n</tr>\n<tr>\n<td>BeforeEachCallback</td>\n<td>在@BeforeEach 注解的方法之前执行</td>\n</tr>\n<tr>\n<td>AfterEachCallback</td>\n<td>在@AfterEach 注解的方法之后执行</td>\n</tr>\n<tr>\n<td>BeforeTestExecutionCallback</td>\n<td>在测试方法运行之前立刻执行</td>\n</tr>\n<tr>\n<td>AfterTestExecutionCallback</td>\n<td>在测试方法运行之后立刻执行</td>\n</tr>\n<tr>\n<td>ParameterResolver</td>\n<td>用于在运行时动态解析参数</td>\n</tr>\n</tbody>\n</table>\n<p>Extension Context</p>\n<p>Extension Context包含了测试方法的上下文信息，所有的扩展接口都定义了一个包含该参数的接口方法，开发者可以根据Extension Context拿到跟测试方法相关的几乎所有的信息，包括方法注解，测试实例，测试标签等。</p>\n<p>Store</p>\n<p>Extension Context 提供了一个getStore(Namespace namespace)的接口方法，返回了一个Store的对象，用于存储一些数据，方便不同的回调接口之间共享数据。</p>\n<p>Namespace</p>\n<p>如果你需要使用Extension Context里的Store功能，那么你就需要先申请一个Namespace,它可以避免不同的扩展实现误操作同一份数据</p>\n<h2 id=\"统计执行时间\" tabindex=\"-1\"> 统计执行时间</h2>\n<p><a href=\"https://gitee.com/dearxuecom/better_test/tree/master/junit-5-advanced/src/test/java/com/dearxue/extensions/benchmark\" target=\"_blank\" rel=\"noopener noreferrer\">extensions&gt;benchmark</a> 例子：</p>\n<div><pre><code>\n<span>class</span> <span>BenchmarkExtension</span>\n    <span>implements</span> <span>BeforeAllCallback</span><span>,</span>\n        <span>BeforeTestExecutionCallback</span><span>,</span>\n        <span>AfterTestExecutionCallback</span><span>,</span>\n        <span>AfterAllCallback</span> <span>{</span>\n\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>BenchmarkExtension</code> 定义扩展点：</p>\n<ol>\n<li>计算所有测试类的运行时间，在所有测试执行前保存其起始时间</li>\n<li>计算每个测试方法的运行时间，在每个测试方法执行前保存其起始时间</li>\n<li>在每个测试方法执行完毕后，获取其结束时间，计算并输出该测试方法的运行时间</li>\n<li>在所有测试类执行完毕后，获取其结束时间，计算并输出所有测试的运行时间</li>\n<li>对所有注解了 <code>@BenchMark</code> 的测试类或测试方法生效</li>\n</ol>\n<p>定义  <code>@Benchmark</code></p>\n<div><pre><code>\n<span>@Target</span><span>(</span><span>{</span> TYPE<span>,</span> METHOD<span>,</span> ANNOTATION_TYPE <span>}</span><span>)</span>\n<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n<span>@ExtendWith</span><span>(</span><span>BenchmarkExtension</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>@interface</span> <span>Benchmark</span> <span>{</span> <span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>测试类：</p>\n<div><pre><code>\n<span>@Benchmark</span>\n<span>public</span> <span>class</span> <span>BenchmarkTest</span> <span>{</span>\n\n  <span>@Test</span>\n  <span>@Benchmark</span>\n  <span>public</span> <span>void</span> <span>test_1</span><span>(</span><span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2_000</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n      e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>@Test</span>\n  <span>public</span> <span>void</span> <span>test_2</span><span>(</span><span>)</span> <span>{</span>\n    <span>try</span> <span>{</span>\n      <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1_000</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n      e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>获得测试输出：</p>\n<div><pre><code>\nTest <span>'test_1()'</span> took <span>2033</span> ms.\nTest container <span>'BenchmarkTest'</span> took <span>2115</span> ms.\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><h2 id=\"test-watcher\" tabindex=\"-1\"> Test Watcher</h2>\n<p><a href=\"https://junit.org/junit5/docs/5.5.1/api/org/junit/jupiter/api/extension/TestWatcher.html\" target=\"_blank\" rel=\"noopener noreferrer\">TestWatcher</a> 接口定义了API扩展，提供钩子函数对测试处理结果进行进一步的处理。</p>\n<p>比如不同过的测试状态：  <code>testDisabled</code> <code>testSuccessful</code> 等等。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>TestResultLoggerExtension</span> \n <span>implements</span> <span>TestWatcher</span><span>,</span> <span>AfterAllCallback</span> <span>{</span>\n\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p>测试用例：</p>\n<div><pre><code><span>@ExtendWith</span><span>(</span><span>TestResultLoggerExtension</span><span>.</span><span>class</span><span>)</span>\n<span>class</span> <span>TestWatcherAPIUnitTest</span> <span>{</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>测试输出</p>\n<div><pre><code>\nTest Disabled <span>for</span> <span>test</span> givenFailure_whenTestDisabledWithReason_ThenCaptureResult<span>(</span><span>)</span>: with reason :- This <span>test</span> is disabled\n<span>..</span><span>..</span>\nTest result summary <span>for</span> TestWatcherAPIUnitTest <span>{</span>ABORTED<span>=</span><span>1</span>, <span>SUCCESSFUL</span><span>=</span><span>1</span>, <span>DISABLED</span><span>=</span><span>2</span><span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"parameter-resolver\" tabindex=\"-1\"> Parameter Resolver</h2>\n<p>我们对 <code>@Random</code> 标注参数， 从上下文注入随机参数 <a href=\"https://gitee.com/dearxuecom/better_test/tree/master/junit5-jupiter-extensions/src/main/java/com/example/random\" target=\"_blank\" rel=\"noopener noreferrer\">junit5-jupiter-extensions&gt;random</a>：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>RandomParametersExtension</span> <span>implements</span> <span>ParameterResolver</span> <span>{</span>\n\n  <span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>\n  <span>@Target</span><span>(</span><span>ElementType</span><span>.</span>PARAMETER<span>)</span>\n  <span>public</span> <span>@interface</span> <span>Random</span> <span>{</span><span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>boolean</span> <span>supportsParameter</span><span>(</span>\n      <span>ParameterContext</span> parameterContext<span>,</span> <span>ExtensionContext</span> extensionContext<span>)</span> <span>{</span>\n    <span>return</span> parameterContext<span>.</span><span>isAnnotated</span><span>(</span><span>Random</span><span>.</span><span>class</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>Object</span> <span>resolveParameter</span><span>(</span>\n      <span>ParameterContext</span> parameterContext<span>,</span> <span>ExtensionContext</span> extensionContext<span>)</span> <span>{</span>\n    <span>return</span> <span>getRandomValue</span><span>(</span>parameterContext<span>.</span><span>getParameter</span><span>(</span><span>)</span><span>,</span> extensionContext<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>private</span> <span>Object</span> <span>getRandomValue</span><span>(</span><span>Parameter</span> parameter<span>,</span> <span>ExtensionContext</span> extensionContext<span>)</span> <span>{</span>\n    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type <span>=</span> parameter<span>.</span><span>getType</span><span>(</span><span>)</span><span>;</span>\n    <span><span>java<span>.</span>util<span>.</span></span>Random</span> random <span>=</span>\n        extensionContext\n            <span>.</span><span>getRoot</span><span>(</span><span>)</span>\n            <span>.</span><span>getStore</span><span>(</span><span>Namespace</span><span>.</span>GLOBAL<span>)</span> <span>//</span>\n            <span>.</span><span>getOrComputeIfAbsent</span><span>(</span><span><span>java<span>.</span>util<span>.</span></span>Random</span><span>.</span><span>class</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span><span>int</span><span>.</span><span>class</span><span>.</span><span>equals</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>\n      <span>return</span> random<span>.</span><span>nextInt</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>if</span> <span>(</span><span>double</span><span>.</span><span>class</span><span>.</span><span>equals</span><span>(</span>type<span>)</span><span>)</span> <span>{</span>\n      <span>return</span> random<span>.</span><span>nextDouble</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>throw</span> <span>new</span> <span>ParameterResolutionException</span><span>(</span><span>\"No random generator implemented for \"</span> <span>+</span> type<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>测试用例：</p>\n<div><pre><code><span>@ExtendWith</span><span>(</span><span>RandomParametersExtension</span><span>.</span><span>class</span><span>)</span>\n<span>class</span> <span>RandomParametersExtensionTests</span> <span>{</span>\n\n  <span>@Test</span>\n  <span>void</span> <span>injectsInteger</span><span>(</span><span>@Random</span> <span>int</span> i<span>,</span> <span>@Random</span> <span>int</span> j<span>)</span> <span>{</span>\n    <span>assertNotEquals</span><span>(</span>i<span>,</span> j<span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Test</span>\n  <span>void</span> <span>injectsDouble</span><span>(</span><span>@Random</span> <span>double</span> d<span>)</span> <span>{</span>\n    <span>assertEquals</span><span>(</span><span>0.0</span><span>,</span> d<span>,</span> <span>1.0</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"参考\" tabindex=\"-1\"> 参考</h2>\n<ol>\n<li><a href=\"https://github.com/ctudose/junit-in-action-third-edition/tree/master/ch14-extensions/src/test/java/com/manning/junitbook/ch14/extensions\" target=\"_blank\" rel=\"noopener noreferrer\">更复杂关于Datasource上下文的扩展</a></li>\n</ol>\n",
      "date_published": "2022-06-27T15:36:05.000Z",
      "date_modified": "2022-06-27T15:36:05.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Junit 整合",
      "url": "https://www.dearxue.com/web_html_tester/junit/006_junit_integration.html",
      "id": "https://www.dearxue.com/web_html_tester/junit/006_junit_integration.html",
      "content_html": "<p>这里简单演示一个对 <code>mockito</code> 的通过扩展的整合，例子在 <a href=\"https://gitee.com/dearxuecom/better_test/tree/master/junit-5/src/test/java/com/dearxue/junit5/mockito\" target=\"_blank\" rel=\"noopener noreferrer\">junit5&gt;mockito</a></p>\n<p>例子中我们将演示， 如果通过 <code>mockito</code> 实现对于 <code>@Mock</code> 对象自动用  <code>mockito</code> 扩展例子。</p>\n<h2 id=\"依赖\" tabindex=\"-1\"> 依赖</h2>\n<div><pre><code>\ntestImplementation 'org.mockito:mockito-core:4.6.1'\ntestImplementation 'org.mockito:mockito-junit-jupiter:4.6.1'\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><h2 id=\"应用\" tabindex=\"-1\"> 应用</h2>\n<p>基本的几个服务类：</p>\n<div><pre><code>└─mockito\n    │  User.java\n    │\n    ├─repository\n    │      MailClient.java\n    │      SettingRepository.java\n    │      UserRepository.java\n    │\n    └─service\n            DefaultUserService.java\n            Errors.java\n            UserService.java\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>测试类</p>\n<div><pre><code>\n<span>@ExtendWith</span><span>(</span><span>MockitoExtension</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>class</span> <span>UserServiceUnitTest</span> <span>{</span>\n\n  <span>UserService</span> userService<span>;</span>\n  <span>SettingRepository</span> settingRepository<span>;</span>\n  <span>@Mock</span> <span>UserRepository</span> userRepository<span>;</span>\n  <span>@Mock</span> <span>MailClient</span> mailClient<span>;</span>\n\n<span>}</span>\n\n`<span>@Mock</span>` 为我们测试注入 mock 对象， 在每个测试进行前，初始化 fixture<span>:</span>\n\n```java\n\n<span>@BeforeEach</span>\n<span>void</span> <span>init</span><span>(</span><span>@Mock</span> <span>SettingRepository</span> settingRepository<span>)</span> <span>{</span>\n    userService <span>=</span> <span>new</span> <span>DefaultUserService</span><span>(</span>userRepository<span>,</span> settingRepository<span>,</span> mailClient<span>)</span><span>;</span>\n    <span>lenient</span><span>(</span><span>)</span><span>.</span><span>when</span><span>(</span>settingRepository<span>.</span><span>getUserMinAge</span><span>(</span><span>)</span><span>)</span><span>.</span><span>thenReturn</span><span>(</span><span>10</span><span>)</span><span>;</span>\n    <span>when</span><span>(</span>settingRepository<span>.</span><span>getUserNameMinLength</span><span>(</span><span>)</span><span>)</span><span>.</span><span>thenReturn</span><span>(</span><span>4</span><span>)</span><span>;</span>\n    <span>lenient</span><span>(</span><span>)</span><span>.</span><span>when</span><span>(</span>userRepository<span>.</span><span>isUsernameAlreadyExists</span><span>(</span><span>any</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span><span>)</span><span>)</span><span>.</span><span>thenReturn</span><span>(</span><span>false</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span>settingRepository <span>=</span> settingRepository<span>;</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意  <code>Mockito.lenient</code>  Mockito 对处理未使用的 mock 对象会抛出 <code>UnsupportedStubbingException</code> 所以这里用 lenient 避免抛出这样的异常。</p>\n<p>然后看具体测实测用例：</p>\n<div><pre><code>\n<span>@Test</span>\n<span>void</span> <span>givenValidUser_whenSaveUser_thenSucceed</span><span>(</span><span>@Mock</span> <span>MailClient</span> mailClient<span>)</span> <span>{</span>\n    <span>// Given</span>\n    user <span>=</span> <span>new</span> <span>User</span><span>(</span><span>\"Jerry\"</span><span>,</span> <span>12</span><span>)</span><span>;</span>\n    <span>when</span><span>(</span>userRepository<span>.</span><span>insert</span><span>(</span><span>any</span><span>(</span><span>User</span><span>.</span><span>class</span><span>)</span><span>)</span><span>)</span>\n        <span>.</span><span>then</span><span>(</span>\n            <span>new</span> <span>Answer</span><span><span>&lt;</span><span>User</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n              <span>int</span> sequence <span>=</span> <span>1</span><span>;</span>\n\n              <span>@Override</span>\n              <span>public</span> <span>User</span> <span>answer</span><span>(</span><span>InvocationOnMock</span> invocation<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>\n                <span>User</span> user <span>=</span> <span>(</span><span>User</span><span>)</span> invocation<span>.</span><span>getArgument</span><span>(</span><span>0</span><span>)</span><span>;</span>\n                user<span>.</span><span>setId</span><span>(</span>sequence<span>++</span><span>)</span><span>;</span>\n                <span>return</span> user<span>;</span>\n              <span>}</span>\n            <span>}</span><span>)</span><span>;</span>\n\n    userService <span>=</span> <span>new</span> <span>DefaultUserService</span><span>(</span>userRepository<span>,</span> settingRepository<span>,</span> mailClient<span>)</span><span>;</span>\n\n    <span>// When</span>\n    <span>User</span> insertedUser <span>=</span> userService<span>.</span><span>register</span><span>(</span>user<span>)</span><span>;</span>\n\n    <span>// Then</span>\n    <span>verify</span><span>(</span>userRepository<span>)</span><span>.</span><span>insert</span><span>(</span>user<span>)</span><span>;</span>\n    <span>Assertions</span><span>.</span><span>assertNotNull</span><span>(</span>user<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>verify</span><span>(</span>mailClient<span>)</span><span>.</span><span>sendUserRegistrationMail</span><span>(</span>insertedUser<span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>",
      "date_published": "2022-06-27T15:36:05.000Z",
      "date_modified": "2022-06-27T15:36:05.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Junit 基础",
      "url": "https://www.dearxue.com/web_html_tester/junit/002_junit_basic.html",
      "id": "https://www.dearxue.com/web_html_tester/junit/002_junit_basic.html",
      "content_html": "<h2 id=\"注解\" tabindex=\"-1\"> 注解</h2>\n<p>JUnit5常用注：</p>\n<ol>\n<li>@Test :表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li>\n<li>@ParameterizedTest :表示方法是参数化测试，下方会有详细介绍</li>\n<li>@RepeatedTest :表示方法可重复执行，下方会有详细介绍</li>\n<li>@DisplayName :为测试类或者测试方法设置展示名称</li>\n<li>@BeforeEach :表示在每个单元测试之前执行</li>\n<li>@AfterEach :表示在每个单元测试之后执行</li>\n<li>@BeforeAll :表示在所有单元测试之前执行</li>\n<li>@AfterAll :表示在所有单元测试之后执行</li>\n<li>@Tag :表示单元测试类别，类似于JUnit4中的@Categories</li>\n<li>@Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</li>\n<li>@Timeout :表示测试方法运行如果超过了指定时间将会返回错误</li>\n<li>@ExtendWith :为测试类或测试方法提供扩展类引用</li>\n</ol>\n<p>JUnit5 和 Junit4 的变化：</p>\n<table>\n<thead>\n<tr>\n<th>说明</th>\n<th>Junit 4</th>\n<th>Junit 5</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>定义测试方法即用例</td>\n<td>@Test</td>\n<td>@Test</td>\n</tr>\n<tr>\n<td>在当前类中的所有测试方法之前执行</td>\n<td>@BeforeClass</td>\n<td>@BeforeAll</td>\n</tr>\n<tr>\n<td>在当前类中的所有测试方法之后执行</td>\n<td>@AfterClass</td>\n<td>@AfterAll</td>\n</tr>\n<tr>\n<td>在每个测试用例前执行</td>\n<td>@Before</td>\n<td>@BeforeEach</td>\n</tr>\n<tr>\n<td>在每个测试用例后执行</td>\n<td>@After</td>\n<td>@AfterEach</td>\n</tr>\n<tr>\n<td>禁用测试方法或类</td>\n<td>@Ignore</td>\n<td>@Disabled</td>\n</tr>\n<tr>\n<td>Tagging 和 filtering</td>\n<td>@Category</td>\n<td>@Tag</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"实战\" tabindex=\"-1\"> 实战</h2>\n<p>看下这个例子：</p>\n<div><pre><code>\n <span>@BeforeAll</span>\n  <span>public</span> <span>static</span> <span>void</span> <span>init</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"初始化数据\"</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@AfterAll</span>\n  <span>public</span> <span>static</span> <span>void</span> <span>cleanup</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"清理数据\"</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@BeforeEach</span>\n  <span>public</span> <span>void</span> <span>tearup</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前测试方法开始\"</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@AfterEach</span>\n  <span>public</span> <span>void</span> <span>tearDown</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"当前测试方法结束\"</span><span>)</span><span>;</span>\n  <span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后再我们的每个测试例子我们看到这样的输出：</p>\n<div><pre><code>\n初始化数据\n当前测试方法开始\n当前测试方法结束\n当前测试方法开始\n我的第二个测试开始测试\n当前测试方法结束\n当前测试方法开始\n我的第一个测试开始测试\n当前测试方法结束\n当前测试方法开始\n当前测试方法结束\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"fixture\" tabindex=\"-1\"> Fixture</h3>\n<p>Test Fixture 是指一个测试运行所需的固定环境，准确的定义：</p>\n<blockquote>\n<p>The test fixture is everything we need to have in place to exercise the SUT</p>\n</blockquote>\n<p>在进行测试时，我们通常需要把环境设置成已知状态（如创建对象、获取资源等）来创建测试，每次测试开始时都处于一个固定的初始状态；</p>\n<p>测试结果后需要将测试状态还原，所以，测试执行所需要的固定环境称为 Test Fixture。</p>\n<p>细细分析下这个例子， 代码中使用到的一对注解 <strong>@BeforeAll</strong> 和 <strong>@AfterAll</strong> ，它们定义了整个测试类在开始前以及结束时的操作，只能修饰静态方法，主要用于在测试过程中所需要的全局数据和外部资源的初始化和清理。</p>\n<p>与它们不同，<strong>@BeforeEach</strong> 和 <strong>@AfterEach</strong> 所标注的方法会在每个测试用例方法开始前和结束时执行，主要是负责该测试用例所需要的运行环境的准备和销毁， 也就是 fixture 的管理。</p>\n<p><a href=\"https://junit.org/junit5/docs/current/user-guide/#extensions-execution-order-wrapping-behavior\" target=\"_blank\" rel=\"noopener noreferrer\">官方的例子</a> 有非常详尽的描述。</p>\n<p><img src=\"/images/extensions_DatabaseTestsDemo.png\" alt=\"执行周期\" loading=\"lazy\"></p>\n<h3 id=\"禁用\" tabindex=\"-1\"> 禁用</h3>\n<p>禁用执行测试：<code>@Disabled</code></p>\n<p>当我们希望在运行测试类时，跳过某个测试方法，正常运行其他测试用例时，我们就可以用上 @Disabled 注解，表明该测试方法处于不可用，执行测试类的测试方法时不会被 JUnit 执行。</p>\n<p>下面看下使用 <code>@Disbaled</code> 之后的运行效果，在原来测试类中添加如下代码：</p>\n<div><pre><code>\n\n  <span>@DisplayName</span><span>(</span><span>\"我的第三个测试\"</span><span>)</span>\n  <span>@Disabled</span>\n  <span>@Test</span>\n  <span>void</span> <span>testThirdTest</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我的第三个测试开始测试\"</span><span>)</span><span>;</span>\n  <span>}</span>\n\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>都让 <code>@Disabled</code> 也可以使用在类上 也可以使用在类上面。</p>\n<h3 id=\"内嵌\" tabindex=\"-1\"> 内嵌</h3>\n<p>当我们编写的类和代码逐渐增多，随之而来的需要测试的对应测试类也会越来越多。</p>\n<p>为了解决测试类数量爆炸的问题，JUnit 5提供了 <code>@Nested</code> 注解，能够以静态内部成员类的形式对测试用例类进行逻辑分组。</p>\n<p>并且每个静态内部类都可以有自己的生命周期方法， 这些方法将按从外到内层次顺序执行。</p>\n<p>此外，嵌套的类也可以用@DisplayName 标记，这样我们就可以使用正确的测试名称。下面看下简单的用法 <a href=\"https://gitee.com/dearxuecom/better_test/blob/master/001_junit_basic/src/test/java/com/dearxue/tester/NestUnitTest.java\" target=\"_blank\" rel=\"noopener noreferrer\">NestUnitTest</a>：</p>\n<div><pre><code>\n<span>@DisplayName</span><span>(</span><span>\"内嵌测试类\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>NestUnitTest</span> <span>{</span>\n\n  <span>@BeforeEach</span>\n  <span>void</span> <span>init</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"测试方法执行前准备\"</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Nested</span>\n  <span>@DisplayName</span><span>(</span><span>\"第一个内嵌测试类\"</span><span>)</span>\n  <span>class</span> <span>FirstNestTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"第一个内嵌测试类执行测试\"</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>@Nested</span>\n  <span>@DisplayName</span><span>(</span><span>\"第二个内嵌测试类\"</span><span>)</span>\n  <span>class</span> <span>SecondNestTest</span> <span>{</span>\n    <span>@Test</span>\n    <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n      <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"第二个内嵌测试类执行测试\"</span><span>)</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"重复\" tabindex=\"-1\"> 重复</h3>\n<p>重复性测试：<code>@RepeatedTest</code></p>\n<p>在 JUnit 5 里新增了对测试方法设置运行次数的支持，允许让测试方法进行重复运行。</p>\n<p>当要运行一个测试方法 N次时，可以使用 <code>@RepeatedTest</code> 标记它，如下面的代码所示 <a href=\"https://gitee.com/dearxuecom/better_test/blob/master/001_junit_basic/src/test/java/com/dearxue/tester/RepeatedUnitTest.java\" target=\"_blank\" rel=\"noopener noreferrer\">RepeatedUnitTest</a>：</p>\n<div><pre><code><span>@DisplayName</span><span>(</span><span>\"重复测试\"</span><span>)</span>\n<span>@RepeatedTest</span><span>(</span>value <span>=</span> <span>3</span><span>)</span>\n<span>public</span> <span>void</span> <span>i_am_a_repeated_test</span><span>(</span><span>)</span> <span>{</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"执行测试\"</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>当然你也可以定制每次 的 <code>DisplayName</code>:</p>\n<div><pre><code>\n<span>@DisplayName</span><span>(</span><span>\"自定义名称重复测试\"</span><span>)</span>\n<span>@RepeatedTest</span><span>(</span>value <span>=</span> <span>3</span><span>,</span> name <span>=</span> <span>\"{displayName} 第 {currentRepetition} 次\"</span><span>)</span>\n<span>public</span> <span>void</span> <span>i_am_a_repeated_test_2</span><span>(</span><span>)</span> <span>{</span>\n\t<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"执行测试\"</span><span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>@RepeatedTest</code> 注解内用 <code>currentRepetition</code> 变量表示已经重复的次数，<code>totalRepetitions</code> 变量表示总共要重复的次数，</p>\n<p><code>displayName</code> 变量表示测试方法显示名称，我们直接就可以使用这些内置的变量来重新定义测试方法重复运行时的名称。</p>\n<h2 id=\"断言\" tabindex=\"-1\"> 断言</h2>\n<p>在断言 API 设计上，JUnit 5 进行显著地改进，并且充分利用 Java 8 的新特性，特别是 Lambda 表达式，最终提供了新的断言类: <code>org.junit.jupiter.api.Assertions</code> 。</p>\n<p>许多断言方法接受 Lambda 表达式参数，在断言消息使用 Lambda 表达式的一个优点就是它是 <strong>延迟计算</strong>  的，如果消息构造开销很大，这样做一定程度上可以节省时间和资源。</p>\n<p>注意断言是 <code>Assertions</code> 和后面要介绍的 <code>Assumptions</code> (假设) 不太一样。</p>\n<p>现在还可以将一个方法内的多个断言进行分组，使用 assertAll 方法如下示例代码 <a href=\"https://gitee.com/dearxuecom/better_test/blob/master/001_junit_basic/src/test/java/com/dearxue/tester/AppTest.java\" target=\"_blank\" rel=\"noopener noreferrer\">AppTest</a>：</p>\n<div><pre><code>\n<span>@Test</span>\n  <span>void</span> <span>groupAssertions</span><span>(</span><span>)</span> <span>{</span>\n    <span>int</span><span>[</span><span>]</span> numbers <span>=</span> <span>{</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>}</span><span>;</span>\n    <span>assertAll</span><span>(</span>\n        <span>\"numbers\"</span><span>,</span>\n        <span>(</span><span>)</span> <span>-></span> <span>assertEquals</span><span>(</span>numbers<span>[</span><span>0</span><span>]</span><span>,</span> <span>0</span><span>)</span><span>,</span>\n        <span>(</span><span>)</span> <span>-></span> <span>assertEquals</span><span>(</span>numbers<span>[</span><span>3</span><span>]</span><span>,</span> <span>3</span><span>)</span><span>,</span>\n        <span>(</span><span>)</span> <span>-></span> <span>assertEquals</span><span>(</span>numbers<span>[</span><span>4</span><span>]</span><span>,</span> <span>4</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果分组断言中任一个断言的失败，都会将以 <code>MultipleFailuresError</code> 错误进行抛出提示。</p>\n<p>还有很多：</p>\n<ol>\n<li>assertEquals</li>\n<li>assertNotEquals</li>\n<li>assertArrayEquals</li>\n<li>assertIterableEquals</li>\n<li>assertLinesMatch</li>\n<li>assertNotNull  .....</li>\n</ol>\n<p>比较有意思的两个：  assertTimeout  &amp;  assertThrows  具体示范下：</p>\n<h3 id=\"asserttimeout\" tabindex=\"-1\"> assertTimeout</h3>\n<div><pre><code><span>@Test</span>\n  <span>@DisplayName</span><span>(</span><span>\"超时方法测试\"</span><span>)</span>\n  <span>void</span> <span>test_should_complete_in_one_second</span><span>(</span><span>)</span> <span>{</span>\n    <span>Assertions</span><span>.</span><span>assertTimeoutPreemptively</span><span>(</span>\n        <span>Duration</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>ChronoUnit</span><span>.</span>SECONDS<span>)</span><span>,</span> <span>(</span><span>)</span> <span>-></span> <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>900</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个测试运行失败，因为代码执行将休眠两秒钟，而我们期望测试用例在一秒钟之内成功</p>\n<p>但是如果我们把休眠时间设置一秒钟，测试仍然会出现偶尔失败的情况，这是因为测试方法执行过程中除了目标代码还有额外的代码和指令执行会耗时，</p>\n<p>所以在超时限制上无法做到对时间参数的完全精确匹配。</p>\n<h3 id=\"assertthrows\" tabindex=\"-1\"> assertThrows</h3>\n<p>我们代码中对于带有异常的方法通常都是使用 try-catch 方式捕获处理，针对测试这样带有异常抛出的代码，</p>\n<p>而 JUnit 5 提供方法 <code>Assertions#assertThrows(Class&lt;T&gt;, Executable)</code> 来进行测试，第一个参数为异常类型，</p>\n<p>第二个为函数式接口参数，跟 Runnable 接口相似，不需要参数，也没有返回，并且支持 Lambda 表达式方式使用，具体使用方式可参考下方代码：</p>\n<div><pre><code>\n<span>@Test</span>\n<span>void</span> <span>shouldThrowException</span><span>(</span><span>)</span> <span>{</span>\n    <span>Throwable</span> exception <span>=</span>\n        <span>assertThrows</span><span>(</span>\n            <span>UnsupportedOperationException</span><span>.</span><span>class</span><span>,</span>\n            <span>(</span><span>)</span> <span>-></span> <span>{</span>\n              <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>\"Not supported\"</span><span>)</span><span>;</span>\n            <span>}</span><span>)</span><span>;</span>\n    <span>assertEquals</span><span>(</span>exception<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>,</span> <span>\"Not supported\"</span><span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"fail\" tabindex=\"-1\"> fail</h3>\n<p>fail()方法指未通过测试。 在尚未写的例子中可以用这个做个占位符！</p>\n<div><pre><code>\n<span>@Test</span>\n  <span>void</span> <span>testFailCase</span><span>(</span><span>)</span> <span>{</span>\n    <span>Assertions</span><span>.</span><span>fail</span><span>(</span>\n        <span>\"as the method not implement this is a place hold to remind us, usually practice in the TDD\"</span><span>)</span><span>;</span>\n    <span>Assertions</span><span>.</span><span>fail</span><span>(</span><span>AppTest</span><span>::</span><span>message</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>private</span> <span>static</span> <span>String</span> <span>message</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>\"not found good reason to pass\"</span><span>;</span>\n  <span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"假设\" tabindex=\"-1\"> 假设</h2>\n<p>JUnit 5假设类提供静态方法来支持基于假设的条件测试执行。假设失败会导致测试中止， 不会导致失败。</p>\n<p>当继续执行给定的测试方法没有意义时，通常使用假设。在测试报告中，这些测试将被标记为<strong>通过</strong>。</p>\n<p>JUnit Assumptions（假设）类有以下方法：</p>\n<ol>\n<li>Assumptions.assumeTrue()</li>\n<li>Assumptions.assumeFalse()</li>\n<li>Assumptions.assumingThat()</li>\n</ol>\n<p><a href=\"https://gitee.com/dearxuecom/better_test/blob/master/001_junit_basic/src/test/java/com/dearxue/tester/AssumptionsTestExample.java\" target=\"_blank\" rel=\"noopener noreferrer\">AssumptionsTestExample</a> 例子。</p>\n<h3 id=\"assumetrue-assumefalse\" tabindex=\"-1\"> assumeTrue/assumeFalse</h3>\n<ol>\n<li>assumeTrue 该方法验证给定假设为真，如果假设为真，则测试继续进行，否则，测试执行将中止。</li>\n<li>assumeFalse 该方法验证给定假设为假，如果假设为假，则测试继续，否则，测试执行被中止。</li>\n</ol>\n<div><pre><code>\n  <span>@Test</span>\n  <span>void</span> <span>testOnDev</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span><span>setProperty</span><span>(</span><span>\"ENV\"</span><span>,</span> <span>\"DEV\"</span><span>)</span><span>;</span>\n    <span>assumeTrue</span><span>(</span><span>\"DEV\"</span><span>.</span><span>equals</span><span>(</span><span>System</span><span>.</span><span>getProperty</span><span>(</span><span>\"ENV\"</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"测试继续执行...\"</span><span>)</span><span>;</span>\n  <span>}</span>\n  <span>/** 测试失败，打印出失败消息 */</span>\n  <span>@Test</span>\n  <span>void</span> <span>testOnProd</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span><span>setProperty</span><span>(</span><span>\"ENV\"</span><span>,</span> <span>\"PROD\"</span><span>)</span><span>;</span>\n    <span>assumeTrue</span><span>(</span><span>\"DEV\"</span><span>.</span><span>equals</span><span>(</span><span>System</span><span>.</span><span>getProperty</span><span>(</span><span>\"ENV\"</span><span>)</span><span>)</span><span>,</span> <span>AssumptionsTestExample</span><span>::</span><span>message</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"测试不会继续执行，不会打印此行...\"</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>private</span> <span>static</span> <span>String</span> <span>message</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>\"测试失败...\"</span><span>;</span>\n  <span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"assumingthat\" tabindex=\"-1\"> assumingThat</h3>\n<p>该方法执行提供的可执行上下文，但前提是提供的假设有效。与其他假设方法不同，此方法不会中止测试。</p>\n<p>如果该假设无效，则该方法不起任何作用。</p>\n<p>如果假设有效且可执行上下文抛出异常，则它将被视为常规测试失败。</p>\n<p>抛出的异常将按原样重新抛出，但被掩盖为未经检查的异常。</p>\n<div><pre><code><span>@Test</span>\n  <span>void</span> <span>testInAllEnvironments</span><span>(</span><span>)</span> <span>{</span>\n    <span>System</span><span>.</span><span>setProperty</span><span>(</span><span>\"ENV\"</span><span>,</span> <span>\"DEV\"</span><span>)</span><span>;</span>\n    <span>assumingThat</span><span>(</span>\n        <span>\"DEV\"</span><span>.</span><span>equals</span><span>(</span><span>System</span><span>.</span><span>getProperty</span><span>(</span><span>\"ENV\"</span><span>)</span><span>)</span><span>,</span>\n        <span>(</span><span>)</span> <span>-></span> <span>{</span>\n          <span>// 仅在DEV服务器上执行这些断言和打印</span>\n          <span>// 即System.setProperty(\"ENV\", \"DEV\")才会执行</span>\n          <span>assertEquals</span><span>(</span><span>3</span><span>,</span> <span>1</span> <span>+</span> <span>2</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n\n    <span>// 在所有环境中执行这些断言</span>\n    <span>assertEquals</span><span>(</span><span>13</span><span>,</span> <span>6</span> <span>+</span> <span>7</span><span>)</span><span>;</span>\n  <span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>",
      "image": "https://www.dearxue.com/web_html_tester/images/extensions_DatabaseTestsDemo.png",
      "date_published": "2022-06-24T12:23:34.000Z",
      "date_modified": "2022-06-27T15:36:05.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Junit 更多",
      "url": "https://www.dearxue.com/web_html_tester/junit/003_junit_more.html",
      "id": "https://www.dearxue.com/web_html_tester/junit/003_junit_more.html",
      "content_html": "<p>如果大家使用过testNG:</p>\n<blockquote>\n<p>TestNG是Java中的一个测试框架， 类似于JUnit 和NUnit, 功能都差不多， 只是功能更加强大，使用也更方便。</p>\n</blockquote>\n<p>一定会被 testNG(Next Generation的首字母) 里面的一些特征吸引， 比如参数化， 当初也是非常吸引笔者， 现在Junit5中已经都有了！</p>\n<p>不得不说 testNG， 里面有很多的设计， 在新一代的 Junit5 都作了参考， 笔者认为，在开发人员这里Junit 使用比较广泛， 在测试开发人员中 testNG 使用比较多。</p>\n<p>第一次接触 testNG 确实也是团队中 QA 组在用这个，入坑的。</p>\n<h2 id=\"参数\" tabindex=\"-1\"> 参数</h2>\n<p>要使用 JUnit 5 进行参数化测试，除了 junit-jupiter-engine 基础依赖之外，还需要另个模块依赖：<code>junit-jupiter-params</code>，其主要就是提供了编写参数化测试 API。</p>\n<div><pre><code>\n<span>testImplementation</span><span>(</span><span><span>\"org.junit.jupiter:junit-jupiter-params\"</span></span><span>)</span> <span>{</span>\n        because <span>'junit params'</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>例子： <a href=\"https://gitee.com/dearxuecom/better_test/blob/master/001_junit_basic/src/test/java/com/dearxue/tester/ParameterizedUnitTest.java\" target=\"_blank\" rel=\"noopener noreferrer\">ParameterizedUnitTest</a></p>\n<h3 id=\"基本数据源测试\" tabindex=\"-1\"> 基本数据源测试</h3>\n<p>基本数据源测试： <code>@ValueSource</code></p>\n<p><code>@ValueSource</code> 是 JUnit 5 提供的最简单的数据参数源，支持 Java 的八大基本类型和字符串，Class，使用时赋值给注解上对应类型属性，以数组方式传递，示例代码如下：</p>\n<div><pre><code>\n<span>@ParameterizedTest</span>\n  <span>@ValueSource</span><span>(</span>ints <span>=</span> <span>{</span><span>2</span><span>,</span> <span>4</span><span>,</span> <span>8</span><span>}</span><span>)</span>\n  <span>void</span> <span>testNumberShouldBeEven</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>\n    <span>Assertions</span><span>.</span><span>assertEquals</span><span>(</span><span>0</span><span>,</span> num <span>%</span> <span>2</span><span>)</span><span>;</span>\n<span>}</span>\n\n\n<span>@ParameterizedTest</span>\n<span>@ValueSource</span><span>(</span>strings <span>=</span> <span>{</span><span>\"Effective Java\"</span><span>,</span> <span>\"Code Complete\"</span><span>,</span> <span>\"Clean Code\"</span><span>}</span><span>)</span>\n<span>void</span> <span>testPrintTitle</span><span>(</span><span>String</span> title<span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>title<span>)</span><span>;</span>\n<span>}</span>\n\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>@ParameterizedTest</code> 作为参数化测试的必要注解，替代了 <code>@Test</code> 注解。任何一个参数化测试方法都需要标记上该注解。</p>\n<h3 id=\"csv-数据源测试\" tabindex=\"-1\"> CSV 数据源测试</h3>\n<p>通过 <code>@CsvSource</code> 可以注入指定 CSV 格式 (comma-separated-values) 的一组数据，用每个逗号分隔的值来匹配一个测试方法对应的参数，下面是使用示例：</p>\n<div><pre><code>\n<span>@ParameterizedTest</span>\n<span>@CsvSource</span><span>(</span>\n      delimiter <span>=</span> <span>','</span><span>,</span>\n      value <span>=</span> <span>{</span><span>\"1,One\"</span><span>,</span> <span>\"2,Two\"</span><span>,</span> <span>\"3,Three\"</span><span>}</span><span>)</span>\n<span>void</span> <span>testDataFromCsv</span><span>(</span><span>long</span> id<span>,</span> <span>String</span> name<span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>\"id: %d, name: %s\\n\"</span><span>,</span> id<span>,</span> name<span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以得到结果：</p>\n<div><pre><code>\nid: <span>1</span>, name: One\nid: <span>2</span>, name: Two\nid: <span>3</span>, name: Three\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div></div></div><p>JUnit 还提供了读取外部 CSV 格式文件数据的方式作为数据源的实现，我们只要用 @CsvFileSource 指定资源文件路径即可，使用起来跟 @CsvSource 一样简单。</p>\n<p><code>@CsvFileSource</code> 指定的资源文件路径时要以 <code>/</code> 开始，寻找当前测试资源目录下文件</p>\n<div><pre><code>\n<span>@ParameterizedTest</span>\n<span>@CsvFileSource</span><span>(</span>resources <span>=</span> <span>{</span><span>\"/data.csv\"</span><span>}</span><span>)</span>\n<span>void</span> <span>testDataFromCsvFile</span><span>(</span><span>long</span> id<span>,</span> <span>String</span> name<span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>\"id: %d, name: %s\"</span><span>,</span> id<span>,</span> name<span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>文件目录：</p>\n<div><pre><code>\n├─java\n│  └─com\n│      └─dearxue\n│          └─tester\n│                  ParameterizedUnitTest.java\n│\n└─resources\n        data.csv\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>JUnit 还提供了以下三种数据源参考  <a href=\"https://gitee.com/dearxuecom/better_test/blob/master/001_junit_basic/src/test/java/com/dearxue/tester/ParameterizedUnitTest.java\" target=\"_blank\" rel=\"noopener noreferrer\">ParameterizedUnitTest</a>：</p>\n<ol>\n<li>@EnumSource：允许我们通过参数值，给指定 Enum 枚举类型传入，构造出枚举类型中特定的值。</li>\n<li>@MethodSource：指定一个返回的 Stream / Array / 可迭代对象 的方法作为数据源。 需要注意的是该方法必须是静态的，并且不能接受任何参数。</li>\n<li>@ArgumentSource：通过实现 ArgumentsProvider 接口的参数类来作为数据源，重写它的 provideArguments 方法可以返回自定义类型的 <code>Stream&lt;Arguments&gt;</code> ，作为测试方法所需要的数据使用。</li>\n</ol>\n<h2 id=\"套件\" tabindex=\"-1\"> 套件</h2>\n<p>套件 suite 是个什么？ 听起来像个套餐， 没错他就是个套餐。</p>\n<p>测试套件其实就是JUnit5允许我们运行多个包或者类中的测试方法，也就是分组测试。JUnit5中使用@Suite注解来声明测试套件, BTW 这个概念在testNG 也早就有了。</p>\n<p>在开始分组测试之前，我们先了解几个注解：</p>\n<ol>\n<li>@Tag：测试类和方法可以通过此注解进行标记。这些标签以后可用于过滤测试发现和执行。</li>\n<li>@Disabled：整个测试类或单个测试方法可以通过此注解禁止测试。</li>\n</ol>\n<p>还有更多的这几个：</p>\n<ol>\n<li>@RunWith(JUnitPlatform.class) 执行套件</li>\n<li><strong>@SelectPackages</strong>({&quot;packageA&quot;,&quot;packageB&quot;})创建测试套件</li>\n<li><strong>@SelectClasses</strong>({a.class,b.class,c.class}) 创建测试套件</li>\n<li><strong>@IncludePackages</strong>(&quot;PackageName&quot;) 过滤需要执行的测试包</li>\n<li>@ExcludePackages(&quot;PackageName&quot;) 过滤掉不需要执行的测试包</li>\n<li>@IncludeClassNamePatterns 过滤需要执行的测试类</li>\n<li>@ExcludeClassNamePatterns 过滤不需要执行的测试类</li>\n<li>@IncludeTags(&quot;sit&quot;) 过滤需要执行的测试方法</li>\n<li>@ExcludeTags(&quot;prod&quot;) 过滤不需要执行的测试方法</li>\n</ol>\n<div><pre><code><span>//suite we need</span>\ntestImplementation <span>'org.junit.platform:junit-platform-suite:1.8.2'</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div></div></div><p>例子在 <a href=\"https://gitee.com/dearxuecom/better_test/tree/master/001_junit_basic/src/test/java/com/dearxue/tester/suite\" target=\"_blank\" rel=\"noopener noreferrer\">Junit test suite</a> 包含：</p>\n<ol>\n<li>AssertTest</li>\n<li>LifeCycleTests</li>\n<li>SuiteTests</li>\n</ol>\n<p>可以通过， 包、类 选择方式聚合成 suite, 也通过  tag 进行选择执行， 这个有点类似 spring 里面  component scan, profile 设置。</p>\n<div><pre><code>\n<span>// 将LifeCycleTests和AssertTest这两个类合并在一个分组中进行测试</span>\n<span>@SelectClasses</span><span>(</span><span>{</span><span>LifeCycleTests</span><span>.</span><span>class</span><span>,</span> <span>AssertTest</span><span>.</span><span>class</span><span>}</span><span>)</span>\n<span>// 也可以直接将多个包合并一个组中测试</span>\n<span>// @SelectPackages({\"com.dearxue.tester.suite\"})</span>\n<span>// 这个注解代表只测试含有DEV标签的测试类或者方法</span>\n<span>@IncludeTags</span><span>(</span><span>\"PROD\"</span><span>)</span>\n<span>@Suite</span>\n<span>@SuiteDisplayName</span><span>(</span><span>\"测试套件，分组测试\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>SuiteTests</span> <span>{</span>\n  <span>/**\n   * <span><span><span>&lt;</span>code</span><span>></span></span>\n   <span>*     <span><span>useJUnitPlatform <span>{</span></span></span>\n   *         <span><span><span>// includeTags 'fast'</span></span></span>\n   *         <span><span><span>// excludeTags 'slow'</span></span></span>\n   *     <span><span><span>}</span></span></span>\n   *\n   *</span> <span><span><span>&lt;/</span>code</span><span>></span></span>\n   */</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"参考\" tabindex=\"-1\"> 参考</h2>\n<ol>\n<li><a href=\"https://www.javatpoint.com/testng-tutorial\" target=\"_blank\" rel=\"noopener noreferrer\">testNG</a></li>\n<li><a href=\"https://howtodoinjava.com/junit5/junit5-test-suites-examples/\" target=\"_blank\" rel=\"noopener noreferrer\">JUnit 5 Test Suites</a></li>\n</ol>\n",
      "date_published": "2022-06-24T12:23:34.000Z",
      "date_modified": "2022-06-27T11:39:07.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Junit 高级",
      "url": "https://www.dearxue.com/web_html_tester/junit/004_junit_advanced.html",
      "id": "https://www.dearxue.com/web_html_tester/junit/004_junit_advanced.html",
      "content_html": "<p>涉及到 Junit5 一些深度不太常用的功能， 例子在：<a href=\"https://gitee.com/dearxuecom/better_test/blob/master/001_junit_basic/src/test/java/com/dearxue/tester/advanced\" target=\"_blank\" rel=\"noopener noreferrer\">advanced</a>。</p>\n<h2 id=\"顺序\" tabindex=\"-1\"> 顺序</h2>\n<p>JUnit 5 支持下面几种 MethodOrderer:</p>\n<ol>\n<li>MethodName – 按照函数名字的字母排序。</li>\n<li>DisplayName – 按照显示名词的字母排序。</li>\n<li>OrderAnnotation – 按照 @Order annotation 排序，同order 排序方式可能不一致（所以尽量order 是散列的， 未标注的排最后面。</li>\n<li>Random – 随机排序 种子值可以通过系统配置： junit.jupiter.execution.order.random.seed 来配置。</li>\n<li>Custom – 定制扩展的排序类。</li>\n</ol>\n<p><a href=\"https://gitee.com/dearxuecom/better_test/blob/master/001_junit_basic/src/test/java/com/dearxue/tester/advanced/MethodNameOrderedTests.java\" target=\"_blank\" rel=\"noopener noreferrer\">MethodNameOrderedTests</a> 例子：</p>\n<h3 id=\"methodname\" tabindex=\"-1\"> MethodName</h3>\n<div><pre><code><span>@TestMethodOrder</span><span>(</span><span>MethodOrderer<span>.</span>MethodName</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>class</span> <span>MethodNameOrderedTests</span> \n<span>{</span>\n    <span>@Test</span>\n    <span>void</span> <span>testE</span><span>(</span><span>)</span> <span>{</span>\n        <span>assertTrue</span><span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"displayname\" tabindex=\"-1\"> DisplayName</h3>\n<div><pre><code>\n<span>@TestMethodOrder</span><span>(</span><span>MethodOrderer<span>.</span>DisplayName</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>class</span> <span>DisplayNameOrderedTests</span>\n<span>{</span>\n    <span>@DisplayName</span><span>(</span><span>\"5\"</span><span>)</span>\n    <span>@Test</span>\n    <span>void</span> <span>testE</span><span>(</span><span>)</span> <span>{</span>\n        <span>assertTrue</span><span>(</span><span>true</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"orderannotation\" tabindex=\"-1\"> OrderAnnotation</h3>\n<div><pre><code>\n<span>@TestMethodOrder</span><span>(</span><span>MethodOrderer<span>.</span>OrderAnnotation</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>class</span> <span>OrderAnnotationTests</span> <span>{</span>\n  <span>@Order</span><span>(</span><span>5</span><span>)</span>\n  <span>@Test</span>\n  <span>void</span> <span>testE</span><span>(</span><span>)</span> <span>{</span>\n    <span>assertTrue</span><span>(</span><span>true</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"random\" tabindex=\"-1\"> Random</h3>\n<p>修改 <code>junit-platform.properties</code></p>\n<div><pre><code>junit.jupiter.execution.order.random.seed<span>=</span><span>9999</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>这个测试类， 每次执行的结果顺序都讲不一样！</p>\n<div><pre><code>\n<span>@TestMethodOrder</span><span>(</span><span>MethodOrderer<span>.</span>Random</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>class</span> <span>RandomOrderedTests</span> <span>{</span>\n  <span>@Test</span>\n  <span>void</span> <span>testE</span><span>(</span><span>)</span> <span>{</span>\n    <span>assertTrue</span><span>(</span><span>true</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id=\"custom\" tabindex=\"-1\"> Custom</h3>\n<p>比如一个实现按照接口是否被  <code>Deprecated</code>, 排到最后进行测试：</p>\n<div><pre><code>\n<span>public</span> <span>class</span> <span>DeprecatedInEndTestOrder</span> <span>implements</span> <span>MethodOrderer</span> <span>{</span>\n\n  <span>private</span> <span>Comparator</span><span><span>&lt;</span><span>MethodDescriptor</span><span>></span></span> comparator <span>=</span>\n      <span>Comparator</span><span>.</span><span>comparing</span><span>(</span>md <span>-></span> md<span>.</span><span>getMethod</span><span>(</span><span>)</span><span>.</span><span>isAnnotationPresent</span><span>(</span><span>Deprecated</span><span>.</span><span>class</span><span>)</span><span>)</span><span>;</span>\n\n  <span>@Override</span>\n  <span>public</span> <span>void</span> <span>orderMethods</span><span>(</span><span>MethodOrdererContext</span> context<span>)</span> <span>{</span>\n\n    context<span>.</span><span>getMethodDescriptors</span><span>(</span><span>)</span><span>.</span><span>sort</span><span>(</span>comparator<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后参考测试用例：</p>\n<div><pre><code>\n<span>@TestMethodOrder</span><span>(</span><span>DeprecatedInEndTestOrder</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>class</span> <span>CustomOrderTests</span> <span>{</span>\n  <span>@Test</span>\n  <span>@Deprecated</span>\n  <span>void</span> <span>testC</span><span>(</span><span>)</span> <span>{</span>\n    <span>assertTrue</span><span>(</span><span>true</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@Test</span>\n  <span>void</span> <span>testA</span><span>(</span><span>)</span> <span>{</span>\n    <span>assertTrue</span><span>(</span><span>true</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当然也有正对，测试类自己的排序，这里不再赘述， 参考样例代码。</p>\n<p>默认配置：  <code>junit.jupiter.testclass.order.default = org.junit.jupiter.api.ClassOrderer$OrderAnnotation</code></p>\n<div><pre><code>\n<span>@TestClassOrder</span><span>(</span><span>ClassOrderer<span>.</span>OrderAnnotation</span><span>.</span><span>class</span><span>)</span>\n<span>class</span> <span>OrderedTestClassesExample</span> <span>{</span>\n\n  <span>@Nested</span>\n  <span>@Order</span><span>(</span><span>1</span><span>)</span>\n  <span>class</span> <span>SetupTests</span> <span>{</span>\n\n    <span>@Test</span>\n    <span>void</span> <span>test1</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  <span>}</span>\n\n  <span>@Nested</span>\n  <span>@Order</span><span>(</span><span>2</span><span>)</span>\n  <span>class</span> <span>AppFlowTests</span> <span>{</span>\n\n    <span>@Test</span>\n    <span>void</span> <span>test2</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n  <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"temp-dir\" tabindex=\"-1\"> Temp Dir</h2>\n<p><a href=\"https://junit.org/junit5/docs/current/user-guide/#writing-tests-built-in-extensions-TempDirectory\" target=\"_blank\" rel=\"noopener noreferrer\">@TempDir 尚在实验功能</a> 但是在一些场景下非常有用。</p>\n<p><code>@TempDir</code> 可以使用在方法参数， 类参数， 静态方法，可以用于构建 Fixture， 举个例子 <a href=\"https://gitee.com/dearxuecom/better_test/blob/master/001_junit_basic/src/test/java/com/dearxue/tester/advanced/\" target=\"_blank\" rel=\"noopener noreferrer\">测试目录</a>：</p>\n<div><pre><code>\n<span>@Test</span>\n<span>void</span> <span>tempDirectoryTestOne</span><span>(</span><span>@TempDir</span> <span>Path</span> tempDir<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n    <span>Path</span> tempFile <span>=</span> tempDir<span>.</span><span>resolve</span><span>(</span><span>\"test.txt\"</span><span>)</span><span>;</span>\n\n    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> lines <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>\"dearxue.com\"</span><span>)</span><span>;</span>\n\n    <span>Files</span><span>.</span><span>write</span><span>(</span>tempFile<span>,</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>\"dearxue.com\"</span><span>)</span><span>)</span><span>;</span>\n\n    <span>Assertions</span><span>.</span><span>assertTrue</span><span>(</span><span>Files</span><span>.</span><span>exists</span><span>(</span>tempFile<span>)</span><span>,</span> <span>\"Temp File should have been created\"</span><span>)</span><span>;</span>\n    <span>Assertions</span><span>.</span><span>assertEquals</span><span>(</span><span>Files</span><span>.</span><span>readAllLines</span><span>(</span>tempFile<span>)</span><span>,</span> lines<span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>@TempDir</code> 作为成员变量， 那么每个测试用例都会创建一个新的临时测试目录， 然后再删除参考 <strong>TempDirTest2</strong>。</p>\n<div><pre><code>\ntest1 dir:  C:<span>\\</span>Users<span>\\</span>dearxue<span>\\</span>AppData<span>\\</span>Local<span>\\</span>Temp<span>\\</span>junit3449074755074304313\ntest2 dir:  C:<span>\\</span>Users<span>\\</span>dearxue<span>\\</span>AppData<span>\\</span>Local<span>\\</span>Temp<span>\\</span>junit7411092462858685015\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div></div></div><p><code>@TempDir</code> 作为<strong>静态</strong>成员变量， 和成员变量不一样， 这里一个测试类中不同测试方法会共享一个目录。</p>\n<h2 id=\"测试名称\" tabindex=\"-1\"> 测试名称</h2>\n<p>在一些场景下你希望获取测试名词， 可以通过  <code>TestInfo</code> 上下文获得 <a href=\"https://gitee.com/dearxuecom/better_test/tree/master/junit-5-advanced/src/test/java/com/dearxue/gettestname\" target=\"_blank\" rel=\"noopener noreferrer\">gettestname 例子</a>：</p>\n<div><pre><code>\n<span>@Test</span>\n<span>void</span> <span>givenNumbers_whenOddCheck_thenVerify</span><span>(</span><span>TestInfo</span> testInfo<span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"displayName = \"</span> <span>+</span> testInfo<span>.</span><span>getDisplayName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>int</span> number <span>=</span> <span>5</span><span>;</span>\n    <span>assertTrue</span><span>(</span><span>oddCheck</span><span>(</span>number<span>)</span><span>)</span><span>;</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>获得输出：</p>\n<div><pre><code>displayName <span>=</span> givenNumbers_whenOddCheck_thenVerify<span>(</span>TestInfo<span>)</span>\n</code></pre><div aria-hidden=\"true\"><div></div></div></div><p>参数化场景可以通过 <code>@BeforeEach</code>  获得：</p>\n<div><pre><code><span>private</span> <span>TestInfo</span> testInfo<span>;</span>\n\n  <span>@BeforeEach</span>\n  <span>void</span> <span>init</span><span>(</span><span>TestInfo</span> testInfo<span>)</span> <span>{</span>\n    <span>this</span><span>.</span>testInfo <span>=</span> testInfo<span>;</span>\n  <span>}</span>\n\n  <span>private</span> <span>boolean</span> <span>oddCheck</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>number <span>%</span> <span>2</span> <span>!=</span> <span>0</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>@ParameterizedTest</span><span>(</span>name <span>=</span> <span>\"givenNumbers_whenOddCheck_thenVerify{0}\"</span><span>)</span>\n  <span>@ValueSource</span><span>(</span>ints <span>=</span> <span>{</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>-</span><span>3</span><span>,</span> <span>15</span><span>}</span><span>)</span>\n  <span>void</span> <span>givenNumbers_whenOddCheck_thenVerify</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"displayName = \"</span> <span>+</span> testInfo<span>.</span><span>getDisplayName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>assertTrue</span><span>(</span><span>oddCheck</span><span>(</span>number<span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>输出为：</p>\n<div><pre><code>\ndisplayName <span>=</span> givenNumbers_whenOddCheck_thenVerify5\ndisplayName <span>=</span> givenNumbers_whenOddCheck_thenVerify-3\ndisplayName <span>=</span> givenNumbers_whenOddCheck_thenVerify3\ndisplayName <span>=</span> givenNumbers_whenOddCheck_thenVerify1\ndisplayName <span>=</span> givenNumbers_whenOddCheck_thenVerify15\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"test-instance\" tabindex=\"-1\"> Test Instance</h2>\n<p>默认情况下， Junit  会为每个测试方法创建一个新的instance,这样保持状态的隔离：</p>\n<div><pre><code>\n<span>class</span> <span>AdditionTest</span> <span>{</span>\n\n    <span>private</span> <span>int</span> sum <span>=</span> <span>1</span><span>;</span>\n\n    <span>@Test</span>\n    <span>void</span> <span>addingTwoReturnsThree</span><span>(</span><span>)</span> <span>{</span>\n        sum <span>+=</span> <span>2</span><span>;</span>\n        <span>assertEquals</span><span>(</span><span>3</span><span>,</span> sum<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Test</span>\n    <span>void</span> <span>addingThreeReturnsFour</span><span>(</span><span>)</span> <span>{</span>\n        sum <span>+=</span> <span>3</span><span>;</span>\n        <span>assertEquals</span><span>(</span><span>4</span><span>,</span> sum<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>比如这个测试用例，  两个测试方法执行前， 新的事例被创建， sum 被初始化为1， 所以每个方法都能成立。</p>\n<p>如果共享一个事例， 那么第二个方法会失败。</p>\n<p>但是在一些情况下我们需要， 共享这些变量， 比如一些非常耗时的操作, 这个时候  <code>TestInstance</code> 派上用场了。</p>\n<p><code>@TestInstance</code> 两种模式一个是：LifeCycle.PER_METHOD (默认的)， 另外一个是LifeCycle.PER_CLASS。</p>\n<p>在 <code>PER_CLASS</code> 模式下， 我们可以看到下面例子的变量和方法都不是 <code>static</code> 但是能够照常运行。</p>\n<div><pre><code><span>@TestInstance</span><span>(</span><span>LifeCycle</span><span>.</span>PER_CLASS<span>)</span>\n<span>class</span> <span>TweetSerializerUnitTest</span> <span>{</span>\n\n    <span>private</span> <span>String</span> largeContent<span>;</span>\n\n    <span>@BeforeAll</span>\n    <span>void</span> <span>setUpFixture</span><span>(</span><span>)</span> <span>{</span>\n        <span>// read the file</span>\n    <span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id=\"手动启动测试\" tabindex=\"-1\"> 手动启动测试</h2>\n<p>你可以直接从 <code>java</code> 启动测试用例， 对整个junit 运行逐层debug，洞悉运行过程。</p>\n<div><pre><code>testRuntimeOnly(\"org.junit.platform:junit-platform-launcher\") {\n        because 'allows tests to run from IDEs that bundle older version of launcher'\n}\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>添加依赖， <a href=\"https://gitee.com/dearxuecom/better_test/tree/master/junit-5/src/test/java/com/dearxue/runfromjava\" target=\"_blank\" rel=\"noopener noreferrer\">例子参考</a></p>\n<div><pre><code><span>public</span> <span>void</span> <span>runOne</span><span>(</span><span>)</span> <span>{</span>\n    <span>LauncherDiscoveryRequest</span> request <span>=</span>\n        <span>LauncherDiscoveryRequestBuilder</span><span>.</span><span>request</span><span>(</span><span>)</span>\n            <span>.</span><span>selectors</span><span>(</span><span>selectClass</span><span>(</span><span>FirstUnitTest</span><span>.</span><span>class</span><span>)</span><span>)</span>\n            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>\n    <span>Launcher</span> launcher <span>=</span> <span>LauncherFactory</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>\n    <span>TestPlan</span> testPlan <span>=</span> launcher<span>.</span><span>discover</span><span>(</span>request<span>)</span><span>;</span>\n\n    launcher<span>.</span><span>registerTestExecutionListeners</span><span>(</span>listener<span>)</span><span>;</span>\n    launcher<span>.</span><span>execute</span><span>(</span>request<span>)</span><span>;</span>\n  <span>}</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>输出：</p>\n<div><pre><code>\njunit-5:RunJUnit5TestsFromJava.main<span>(</span><span>)</span>\n\nTest run finished after <span>171</span> ms\n<span>[</span>         <span>6</span> containers found      <span>]</span>\n<span>[</span>         <span>0</span> containers skipped    <span>]</span>\n<span>[</span>         <span>6</span> containers started    <span>]</span>\n<span>[</span>         <span>0</span> containers aborted    <span>]</span>\n<span>[</span>         <span>6</span> containers successful <span>]</span>\n<span>[</span>         <span>0</span> containers failed     <span>]</span>\n<span>[</span>        <span>18</span> tests found           <span>]</span>\n<span>[</span>         <span>0</span> tests skipped         <span>]</span>\n<span>[</span>        <span>18</span> tests started         <span>]</span>\n<span>[</span>         <span>0</span> tests aborted         <span>]</span>\n<span>[</span>        <span>18</span> tests successful      <span>]</span>\n<span>[</span>         <span>0</span> tests failed          <span>]</span>\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>",
      "date_published": "2022-06-24T12:22:58.000Z",
      "date_modified": "2022-06-27T15:36:05.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Spring 背景",
      "url": "https://www.dearxue.com/web_html_tester/spring/",
      "id": "https://www.dearxue.com/web_html_tester/spring/",
      "content_html": "<p>Spring 作为最流行的JAVA 企业开发框架，不仅其框架自身有严格的测试覆盖率；</p>\n<p>也提供了完善的测试扩展和套件， 让测试 Spring/Spring Boot/Spring Cloud 系列项目能够更加容易。</p>\n<ol start=\"3\">\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Testing</a></li>\n<li><a href=\"https://github.com/spring-projects/spring-framework/\" target=\"_blank\" rel=\"noopener noreferrer\">Spring 源码</a></li>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#appendix.dependency-versions.coordinates\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot 版本</a></li>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot Testing</a></li>\n<li><a href=\"https://github.com/spring-projects/spring-boot/\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot 源码</a></li>\n<li><a href=\"https://github.com/spring-guides/gs-testing-web\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Guid Web Test Code</a></li>\n<li><a href=\"https://spring.io/guides/gs/testing-web/\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Guid Web Test</a></li>\n<li><a href=\"https://www.baeldung.com/category/testing/\" target=\"_blank\" rel=\"noopener noreferrer\">Baeldung Test</a></li>\n<li><a href=\"https://www.baeldung.com/spring-boot-testing\" target=\"_blank\" rel=\"noopener noreferrer\">Baeldung Spring boot test</a></li>\n</ol>\n",
      "date_published": "2022-06-23T11:24:30.000Z",
      "date_modified": "2022-06-30T01:34:42.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Junit 历史",
      "url": "https://www.dearxue.com/web_html_tester/junit/001_junit_concept.html",
      "id": "https://www.dearxue.com/web_html_tester/junit/001_junit_concept.html",
      "content_html": "<h2 id=\"背景\" tabindex=\"-1\"> 背景</h2>\n<p>JUnit作为目前Java领域内最为流行的单元测试框架已经走过了数十年。而JUnit5在JUnit4停止更新版本的3年后终于也于2017年发布了。</p>\n<p>作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。首先Junit5由来自三个不同子项目的几个不同模块组成：</p>\n<p><code>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</code></p>\n<p><img src=\"/images/junit5-architecture_01.jpg\" alt=\"架构包\" loading=\"lazy\"></p>\n<ol>\n<li>JUnit Platform： 用于JVM上启动测试框架的基础服务，提供命令行，IDE和构建工具等方式执行测试的支持。</li>\n<li>JUnit Jupiter：包含 JUnit 5 新的编程模型和扩展模型，主要就是用于编写测试代码和扩展代码。</li>\n<li>JUnit Vintage：用于在JUnit 5 中兼容运行 JUnit3.x 和 JUnit4.x 的测试用例。</li>\n</ol>\n<p>JUnit 5，首先需要 Java 8 以上的运行环境，虽然在旧版本 JDK 也能编译运行，但要完全使用 JUnit 5 功能， JDK 8 环境是必不可少的，JUnit 5 这个版本，主要特性：</p>\n<ol>\n<li>提供全新的断言和测试注解，支持测试类内嵌</li>\n<li>更丰富的测试方式：支持动态测试，重复测试，参数化测试等</li>\n<li>实现了模块化，让测试执行和测试发现等不同模块解耦，减少依赖</li>\n<li>提供对 Java 8 的支持，如 Lambda 表达式，Sream API等。</li>\n</ol>\n<p>JUnit 5 Big Picture：</p>\n<p><img src=\"/images/more_easy_style.png\" alt=\"junit arch with layer\" loading=\"lazy\"></p>\n<p>JUint5似乎已经不再满足于安安静静做一个单元测试框架了，它的野心很大，想通过接入不同测试引擎，来支持各类测试框架的使用，成为一个单元测试的平台。</p>\n<p>因此它也采用了分层的架构，分成了平台层，引擎层，框架层。</p>\n<p>Junit5 整体包图 ：</p>\n<p><img src=\"/images/component-diagram.svg\" alt=\"Junit5 整体包图\" loading=\"lazy\"></p>\n<p>根据模块化的思路, JUnit 5 平台拆分如下:</p>\n<ol>\n<li>junit-platform-commons, 内部公用包</li>\n<li>junit-platform-console, 控制台运行</li>\n<li>junit-platform-console-standalone 控制台直接一个全的jar包运行</li>\n<li>junit-platform-engine, 测试引擎 API</li>\n<li>junit-platform-launcher, IDE 运行测试工具</li>\n<li>junit-platform-runner, JUnit4 上执行测试套件</li>\n<li>junit-platform-suite-api, annotations 配置测试套件</li>\n<li>junit-platform-surefire-provider, Maven 插件</li>\n<li>junit-platform-gradle-plugin, Gradle 插件</li>\n</ol>\n<p>JUnit Jupiter 包含核心依赖包:</p>\n<ol>\n<li>junit-jupiter-api, 用来写 tests &amp; extensions</li>\n<li>junit-jupiter-engine, JUnit Jupiter 测试引擎实现, 只在运行时候使用</li>\n<li>junit-jupiter-params, 提供参数测试， 有点类似 TestNG</li>\n<li>junit-jupiter-migrationsupport,  将测试 JUnit 4 迁移到 JUnit Jupiter, 只有用 JUnit 4 规则.</li>\n</ol>\n<p>这个图可以更具体看出 Junit5 在逻辑层， 和各个包的分布关系图：</p>\n<p><img src=\"/images/junit5-architecture_03.png\" alt=\"架构包\" loading=\"lazy\"></p>\n<h3 id=\"junit-bom\" tabindex=\"-1\"> Junit BOM</h3>\n<p>Junit 基本的信息都了解了， 下面就进入Junit 的实践过程, Junit5 拆分成多个包， 所以统一使用BOM 方式管理， 现在只需要引入以下一个包即可</p>\n<div><pre><code>\ntestImplementation(platform(&quot;org.junit:junit-bom:5.8.2&quot;))\ntestRuntimeOnly(&quot;org.junit.platform:junit-platform-launcher&quot;) {\n  because(&quot;Only needed to run tests in a version of IntelliJ IDEA that bundles older versions&quot;)\n}\ntestRuntimeOnly(&quot;org.junit.jupiter:junit-jupiter-engine&quot;)\ntestRuntimeOnly(&quot;org.junit.vintage:junit-vintage-engine&quot;)\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>JUnit5是运行在JUnit Platform上的，所以还需要在build.gradle中加上这个：</p>\n<div><pre><code>test {\n    useJUnitPlatform()\n}\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><p>参考文件： <a href=\"https://gitee.com/dearxuecom/better_test/blob/master/junit5-jupiter-starter-gradle/src/test/java/com/example/project/CalculatorTests.java\" target=\"_blank\" rel=\"noopener noreferrer\">CalculatorTests</a></p>\n<div><pre><code>\n<span>public</span> <span>class</span> <span>Calculator</span> <span>{</span>\n\n  <span>public</span> <span>int</span> <span>add</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>\n    <span>return</span> a <span>+</span> b<span>;</span>\n  <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>\n<span>class</span> <span>CalculatorTests</span> <span>{</span>\n\n  <span>@Test</span>\n  <span>@DisplayName</span><span>(</span><span>\"1 + 1 = 2\"</span><span>)</span>\n  <span>void</span> <span>addsTwoNumbers</span><span>(</span><span>)</span> <span>{</span>\n    <span>Calculator</span> calculator <span>=</span> <span>new</span> <span>Calculator</span><span>(</span><span>)</span><span>;</span>\n    <span>assertEquals</span><span>(</span><span>2</span><span>,</span> calculator<span>.</span><span>add</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span><span>,</span> <span>\"1 + 1 should equal 2\"</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>测试结果：</p>\n<div><pre><code>\nCalculatorTests <span>></span> <span>1</span> + <span>1</span> <span>=</span> <span>2</span> PASSED\n\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div></div></div><h2 id=\"参考\" tabindex=\"-1\"> 参考</h2>\n<p>Java 世界的其他测试框架：</p>\n<ol>\n<li>TestNG</li>\n<li>AssertJ:  可以builder 模式构建调用链</li>\n<li>Hamcrest</li>\n<li>Mockito</li>\n<li>JSONAssert</li>\n<li>JsonPath</li>\n</ol>\n",
      "image": "https://www.dearxue.com/web_html_tester/images/junit5-architecture_01.jpg",
      "date_published": "2022-06-23T11:11:17.000Z",
      "date_modified": "2022-06-27T11:39:07.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Junit 概览",
      "url": "https://www.dearxue.com/web_html_tester/junit/",
      "id": "https://www.dearxue.com/web_html_tester/junit/",
      "content_html": "<h2 id=\"java-unit\" tabindex=\"-1\"> Java Unit</h2>\n<p>什么是单元测试呢？单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。</p>\n<p>单元测试有什么好处呢？在学习单元测试前，我们可以先了解一下测试驱动开发。</p>\n<p>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：</p>\n<div><pre><code>    编写接口\n     │\n     ▼\n    编写测试\n     │\n     ▼\n┌─<span>></span> 编写实现\n│    │\n│ N  ▼\n└── 运行测试\n     │ Y\n     ▼\n    任务完成\n</code></pre><div aria-hidden=\"true\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这就是所谓的 TDD</p>\n<p>JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。</p>\n<p>JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。</p>\n<p>使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。</p>\n<p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试。JUnit目前最新版本是5。</p>\n<p><img src=\"/images/tdd-dead.png\" alt=\"TDD DIE\" loading=\"lazy\"></p>\n<p>大部分反对TDD的声音就是基于这个理解，比如：</p>\n<ol>\n<li>工期紧，时间短，写TDD太浪费时间；</li>\n<li>业务需求变化太快，修改功能都来不及，根本没有时间来写TDD；</li>\n<li>写TDD对开发人员的素质要求非常高，普通的开发人员不会写；</li>\n<li>TDD 推行的最大问题在于大多数程序员还不会「写测试用例」和「重构」；</li>\n<li>由于大量使用Mock和Stub技术，导致UT没有办法测试集成后的功能，对于测试业务价值作用不大。</li>\n</ol>\n<p>TDD 争论很多， 暂且不关注， 我们关注的还是<a href=\"https://insights.thoughtworks.cn/talk-about-tdd-again/\" target=\"_blank\" rel=\"noopener noreferrer\">测试本身</a>。</p>\n",
      "image": "https://www.dearxue.com/web_html_tester/images/tdd-dead.png",
      "date_published": "2022-06-23T11:11:17.000Z",
      "date_modified": "2022-06-27T11:39:07.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "项目地址",
      "url": "https://www.dearxue.com/web_html_tester/github.html",
      "id": "https://www.dearxue.com/web_html_tester/github.html",
      "content_html": "<h1 id=\"项目地址\" tabindex=\"-1\"> 项目地址</h1>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>链接</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>测试学练项目</td>\n<td><a href=\"https://gitee.com/dearxuecom/better_test\" target=\"_blank\" rel=\"noopener noreferrer\">better_test</a></td>\n<td>文中用的例子</td>\n</tr>\n<tr>\n<td>Spring</td>\n<td><a href=\"https://github.com/spring-projects/spring-framework\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Github</a></td>\n<td>Spring 是如何用测试</td>\n</tr>\n<tr>\n<td>Spring Boot</td>\n<td><a href=\"https://github.com/spring-projects/spring-boot/\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot Github</a></td>\n<td>Spring boot 是如何测试</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2022-06-23T07:11:29.000Z",
      "date_modified": "2022-06-28T00:11:33.000Z",
      "authors": [],
      "tags": [
        "Test"
      ]
    },
    {
      "title": "第二学院 原则",
      "url": "https://www.dearxue.com/web_html_tester/principle.html",
      "id": "https://www.dearxue.com/web_html_tester/principle.html",
      "content_html": "<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>时间</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0.0.1</td>\n<td>2022/06/22</td>\n<td>第一版 @第二学院</td>\n</tr>\n<tr>\n<td>0.0.x</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"原则\" tabindex=\"-1\"> 原则</h2>\n<ol>\n<li>第一性原理</li>\n<li>开放原则</li>\n<li>追本溯源</li>\n<li>协同效应</li>\n<li>长期目标</li>\n</ol>\n<h2 id=\"由来\" tabindex=\"-1\"> 由来</h2>\n<ol>\n<li><strong>DEAR</strong>: <code>亲爱</code>\n<ol>\n<li>保持愉悦</li>\n<li>保持真诚</li>\n</ol>\n</li>\n<li><strong>DEAR</strong>：<code>第二</code> 谐音\n<ol>\n<li>第二曲线</li>\n<li>第二春天</li>\n<li>第二机会</li>\n</ol>\n</li>\n<li><strong>DEAR</strong>: <code>鹿</code>(DEER)\n<ol>\n<li>优雅</li>\n<li>单纯</li>\n<li>好奇</li>\n</ol>\n</li>\n<li><strong>XUE</strong>: <code>学</code>\n<ol>\n<li>学而时习</li>\n<li>主动探索</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"写作\" tabindex=\"-1\"> 写作</h2>\n<ol>\n<li>教程\n<ol>\n<li>背景</li>\n<li>原理</li>\n<li>分析</li>\n</ol>\n</li>\n<li>项目\n<ol>\n<li>演示</li>\n<li>实战</li>\n</ol>\n</li>\n<li>附录\n<ol>\n<li>术语表</li>\n<li>参考表</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"不是\" tabindex=\"-1\"> 不是</h2>\n<ol>\n<li>非教学网站， 不教\\授，不解惑、不答疑！</li>\n<li>无承诺, <s>21天学会XXX</s>， <s>XXX进大厂</s></li>\n<li>无赚钱、理财、投资之道， <s>月入XXX万</s></li>\n<li>不贩卖焦虑</li>\n</ol>\n<h2 id=\"思考\" tabindex=\"-1\"> 思考</h2>\n<p><img src=\"/images/why_what_how.png\" alt=\"WHY WHAT HOW\" loading=\"lazy\"></p>\n<ol>\n<li>What：我是写程序\n<ol>\n<li>程序能运作</li>\n<li>问题能解决</li>\n</ol>\n</li>\n<li>How： 我是怎么写程序\n<ol>\n<li>有思考</li>\n<li>有架构</li>\n<li>有模式</li>\n<li>有原则</li>\n</ol>\n</li>\n<li>Why： 我为什么去写程序\n<ol>\n<li>赚钱，养家糊口</li>\n<li>爱好，喜欢捣鼓</li>\n<li>帮助，帮助他人</li>\n<li>改变，改变世界</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"组织\" tabindex=\"-1\"> 组织</h2>\n<ol>\n<li><a href=\"https://gitee.com/dearxuecom\" target=\"_blank\" rel=\"noopener noreferrer\">gitee</a></li>\n<li><a href=\"https://github.com/dearxuecom\" target=\"_blank\" rel=\"noopener noreferrer\">github</a></li>\n<li><a href=\"https://dearxue.com\" target=\"_blank\" rel=\"noopener noreferrer\">official web</a></li>\n</ol>\n<h2 id=\"参考\" tabindex=\"-1\"> 参考</h2>\n<blockquote>\n<p>“I don’t know what’s the matter with people: they don’t learn by understanding; they learn by some other way—by rote or something. Their knowledge is so fragile!”\n— Richard Feynman</p>\n</blockquote>\n<p><a href=\"https://fs.blog/first-principles/\" target=\"_blank\" rel=\"noopener noreferrer\">First Principles: The Building Blocks of True Knowledge</a></p>\n<p><img src=\"https://149664534.v2.pressablecdn.com/wp-content/uploads/2018/04/first-principles-white.jpg\" alt=\"First Principles\" loading=\"lazy\"></p>\n",
      "image": "https://www.dearxue.com/web_html_tester/images/why_what_how.png",
      "date_published": "2022-06-23T07:11:29.000Z",
      "date_modified": "2022-06-30T01:34:42.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "测试背景",
      "url": "https://www.dearxue.com/web_html_tester/theory/001_about_test.html",
      "id": "https://www.dearxue.com/web_html_tester/theory/001_about_test.html",
      "content_html": "<h2 id=\"软件测试是什么\" tabindex=\"-1\"> 软件测试是什么</h2>\n<p>软件测试主要测试软件的这几纬度：</p>\n<ol>\n<li>可靠性, Reliability</li>\n<li>可伸缩性, Scalability</li>\n<li>可移植性, Portability</li>\n<li>可复用, Reliability</li>\n<li>可用性, Usability</li>\n</ol>\n<p>评估软件组件的执行以发现软件的 <code>错误</code>+<code>缺陷</code>。</p>\n<p><img src=\"/images/software-testing-introduction.png\" alt=\"软件的特征\" loading=\"lazy\"></p>\n<p>测试是一组技术，用于确定预定行为下应用程序的正确性，但是，测试无法找到应用程序的所有缺陷。</p>\n<p>测试的主要目的是检测应用程序的故障，以便发现和纠正故障。它并不表明产品在所有条件下都正常工作。</p>\n<h2 id=\"测试种类\" tabindex=\"-1\"> 测试种类</h2>\n<p><img src=\"/images/type-of-software-testing.png\" alt=\"image\" loading=\"lazy\"></p>\n<p>可以看到整个测试的流程还是非常复杂， 所以一般有专门的质量保证QA 团队来负责；</p>\n<p>但是软件的质量保证是全流程控制事件， 从立项设计之初就已经涉及，贯穿软件开发的整个生命周期。</p>\n<h2 id=\"参考\" tabindex=\"-1\"> 参考</h2>\n<ol>\n<li><a href=\"https://www.javatpoint.com/software-testing-tutorial\" target=\"_blank\" rel=\"noopener noreferrer\">Software Testing Tutorial - java point</a></li>\n</ol>\n",
      "image": "https://www.dearxue.com/web_html_tester/images/software-testing-introduction.png",
      "date_published": "2022-06-23T07:11:29.000Z",
      "date_modified": "2022-06-23T07:11:29.000Z",
      "authors": [],
      "tags": [
        "测试"
      ]
    },
    {
      "title": "测试原则",
      "url": "https://www.dearxue.com/web_html_tester/theory/002_test_principle.html",
      "id": "https://www.dearxue.com/web_html_tester/theory/002_test_principle.html",
      "content_html": "<h2 id=\"测试7大原则\" tabindex=\"-1\"> 测试7大原则</h2>\n<p><img src=\"/images/software-testing-principles.png\" alt=\"7 大原则\" loading=\"lazy\"></p>\n<ol>\n<li>Testing shows the presence of defects</li>\n<li>Exhaustive Testing is not possible</li>\n<li>Early Testing</li>\n<li>Defect Clustering</li>\n<li>Pesticide Paradox</li>\n<li>Testing is context-dependent</li>\n<li>Absence of errors fallacy</li>\n</ol>\n<h3 id=\"测试显示bug的存在\" tabindex=\"-1\"> 测试显示bug的存在</h3>\n<p>测试应用程序只能显示在应用程序中存在一个或多个缺陷，但是，仅仅通过测试并不能证明应用程序没有错误。因此，设计测试用例使其尽可能多的找到缺陷是很重要的。</p>\n<h3 id=\"穷举测试不可能\" tabindex=\"-1\"> 穷举测试不可能</h3>\n<p>除非受测试应用（UAT）具有非常简单的逻辑结构和有限的输入，进行所有测试数据和场景的组合是不可能的事。出于这个原因，风险评估和优先级被用于集中测试最重要的方面。</p>\n<h3 id=\"尽早测试\" tabindex=\"-1\"> 尽早测试</h3>\n<p>我们越早开始测试活动，就越可以更好的利用可用的时间。当最初的产品，例如要求或设计文件完成后，我们就可以开始测试。测试阶段常会在开发周期的最后部分也就是开发完成之后遭到时间压缩。因此，尽早开始测试，我们可以针对开发生命周期的每个阶段进行测试的准备。</p>\n<p>另一个关于尽早测试的重要的一点是，当缺陷在生命周期中更早的被发现时，它们更容易解决而且成本更低。改变不正确的要求比起必须改变一个大型系统中没有按照要求或设计来工作的功能要成本低得多！</p>\n<h3 id=\"缺陷群\" tabindex=\"-1\"> 缺陷群</h3>\n<p>在测试过程中，可以观察到，大多数报告的缺陷都与少数几个系统内的模块有关。即少量模块包含了系统中大部分的缺陷。这也是帕雷托法则（二八定律）在软件测试方面的实际应用：约80％的问题被发现在20%的模块中。</p>\n<h3 id=\"杀虫剂悖论\" tabindex=\"-1\"> 杀虫剂悖论</h3>\n<p>如果持续运行同一套测试一遍又一遍，有可能那些测试用例就无法发现新的缺陷。因为随着系统的发展，许多以前报道的缺陷将会被修好，旧的测试用例就不再适用了。每当修复完缺陷或添加了新的功能后，我们需要做回归测试，以确保新更改的软件不破坏该软件的任何其他部分。然而，这些回归测试用例也需要根据软件本身的变化作出改变，使其能够更加适用并找到新的缺陷。</p>\n<h3 id=\"测试是上下文相关的\" tabindex=\"-1\"> 测试是上下文相关的</h3>\n<p>不同的测试方法，测试技术和测试类型是根据应用程序的类型和性质来决定的。例如，运用于医疗设备上的软件应用程序相比游戏软件需要进行更多的测试。更重要的是医疗设备软件需要基于风险测试，需要符合医疗行业监管以及可能的特殊测试设计技术。出于同样的原因，一个非常受欢迎的网站，需要经过严格的性能试验，以及功能性的测试，以确保性能不受服务器上的负载的影响。</p>\n<h3 id=\"无错谬误\" tabindex=\"-1\"> 无错谬误</h3>\n<p>只是因为测试没有发现软件中的任何缺陷，并不意味着该软件是随时可以发布的。被执行的测试，是否真的找到了大多数缺陷？或者，他们是否根据顾客需求设计检查软件是否满足要求？在发布软件之前，还需要考虑</p>\n<h3 id=\"其他因素\" tabindex=\"-1\"> 其他因素</h3>\n<p>其他原则需要注意的是：</p>\n<ol>\n<li>测试必须由独立的一方来完成。</li>\n<li>测试不应由该开发软件的人或者团队来执行，因为它们趋向于维护程序的正确性。</li>\n<li>最佳人员配置: 于测试需要高度的创造性和责任感，需要将人员正确地分配到各个设计，实施和分析测试案例， 测试数据和测试结果的岗位上去。</li>\n<li>除了有效条件之外，也要对无效的和意想不到的输入条件进行测试。</li>\n<li>程序应该在无效情况下产生正确的消息并在有效情况下产生正确的结果。</li>\n<li>保持测试过程中软件的静态。</li>\n<li>在对程序进行测试用例集的执行过程不能对程序进行修改。</li>\n<li>尽可能提供预期的测试结果。</li>\n<li>测试文档的必要组成部分包括了预期结果的说明，即使提供这样的结果可能是不切实际的。</li>\n</ol>\n",
      "image": "https://www.dearxue.com/web_html_tester/images/software-testing-principles.png",
      "date_published": "2022-06-23T07:11:29.000Z",
      "date_modified": "2022-06-28T00:13:32.000Z",
      "authors": [],
      "tags": [
        "测试"
      ]
    },
    {
      "title": "软件流程",
      "url": "https://www.dearxue.com/web_html_tester/theory/003_development_life_cycle.html",
      "id": "https://www.dearxue.com/web_html_tester/theory/003_development_life_cycle.html",
      "content_html": "<h2 id=\"软件开发流程\" tabindex=\"-1\"> 软件开发流程</h2>\n<p>SDLC:  Software Development Life Cycle</p>\n<p><img src=\"/images/software-development-life-cycle.png\" alt=\"SDLC\" loading=\"lazy\"></p>\n<ol>\n<li>需要，Requirement Phase</li>\n<li>设计，Design Phase</li>\n<li>开发，Build /Development Phase</li>\n<li>测试，Testing Phase</li>\n<li>上线，Deployment/ Deliver Phase</li>\n<li>维护，Maintenance</li>\n</ol>\n<h2 id=\"软件测试流程\" tabindex=\"-1\"> 软件测试流程</h2>\n<p>STLC: Software Testing Life Cycle (STLC)</p>\n<p><img src=\"/images/software-testing-life-cycle.png\" alt=\"STLC\" loading=\"lazy\"></p>\n<ol>\n<li>需求分析 Requirement Analysis</li>\n<li>测试计划 Test Plan Creation</li>\n<li>环境配置 Environment setup</li>\n<li>测试用例执行 Test case Execution</li>\n<li>缺陷等级 Defect Logging</li>\n<li>测试周期结束， 复盘 Test Cycle Closure</li>\n</ol>\n<p>在整个周期中， 几大点需要关注：</p>\n<ol>\n<li>需求的把握</li>\n<li>沟通， 测试沟通非常重要</li>\n<li>文档的沉淀，组织资产</li>\n<li>复盘总结，测试就是不断的应对缺陷和挑战</li>\n</ol>\n<h2 id=\"sdlc-stlc\" tabindex=\"-1\"> SDLC &amp; STLC</h2>\n<p>在一个软件迭代周期内， 可能有多个构建(build) 版本， 无数次测试环境的迭代。</p>\n<p>从一个需求出发， 开发和测试在两个线上进行， 通过构建的版本不停的往复，最终达到一个软件交付的标准；</p>\n<p>至此一个版本的迭代才结束， 在进行下一个，往返始复，直到这个软件退役， 或者相关人员的离去。</p>\n<p><img src=\"/images/test-cycle-software-testing.png\" alt=\"Software Build Process\" loading=\"lazy\"></p>\n<p>再看具体的细分， 现在都有专业的研发效能工具来支撑， 比如 JIRA + Confluence, 阿里的云效等。</p>\n<p><img src=\"/images/real-example-demo.png\" alt=\"Real example\" loading=\"lazy\"></p>\n<ol>\n<li>测试工程师一旦收到错误，他们就会将其发送给开发人员，并且他们需要一些时间来分析之后，他/她修复了错误。</li>\n<li>开发人员会根据时间决定他可以修复多少个 Bug。测试工程师决定，哪个错误应该首先根据他们的需要修复，因为测试工程师不能停止测试。</li>\n<li>测试工程师收到邮件后，他们只能知道哪个 Bug List  中 bug 修复了。</li>\n<li>开始 bug  可能越来越多， 到后来就渐渐减少，因为开发可以只做 bug  修复</li>\n</ol>\n<p><img src=\"/images/devops-tools.png\" alt=\"涉及工具\" loading=\"lazy\"></p>\n",
      "image": "https://www.dearxue.com/web_html_tester/images/software-development-life-cycle.png",
      "date_published": "2022-06-23T07:11:29.000Z",
      "date_modified": "2022-06-28T00:04:39.000Z",
      "authors": [],
      "tags": [
        "测试"
      ]
    },
    {
      "title": "测试类型",
      "url": "https://www.dearxue.com/web_html_tester/theory/004_test_types.html",
      "id": "https://www.dearxue.com/web_html_tester/theory/004_test_types.html",
      "content_html": "<p><img src=\"/images/types-of-software-testing_detail.png\" alt=\"测试类型\" loading=\"lazy\"></p>\n<p>整体上分两大类， 手动和自动</p>\n<h2 id=\"手动测试\" tabindex=\"-1\"> 手动测试</h2>\n<p>手动测试是一个软件测试过程，</p>\n<p>在该过程中，测试用例无需使用任何自动化工具即可手动执行。</p>\n<p>测试人员根据最终用户的视角手动执行所有测试用例。它确保应用程序是否正常工作，如需求文档中所述。 测试用例报告也是手动生成的。</p>\n<p>手动测试是最基本的测试过程之一，因为它可以找到软件的可见和隐藏缺陷。</p>\n<p>软件和预期输出的差异被定义为缺陷(不达到预期)----非bug。开发人员修复了缺陷，并交给测试人员进行重新测试。</p>\n<p>在自动测试之前，每个新开发的软件必须进行手动测试。这种测试需要巨大的努力和时间，但它提供了无错误软件的肯定。</p>\n<p>手动测试需要掌握手动测试技术的知识，但不需要任何自动化测试工具的知识。</p>\n<p><img src=\"/images/manually_test_types.png\" alt=\"手动测试类型\" loading=\"lazy\"></p>\n<h3 id=\"白盒\" tabindex=\"-1\"> 白盒</h3>\n<p><img src=\"/images/types-of-software-testing-wite-box.png\" alt=\"白盒测试法\" loading=\"lazy\"></p>\n<p>也称结构测试或逻辑驱动测试，它是知道产品内部工作过程，可通过测试来检测产品内部动作是否按照规格说明书的规定正常进行，按照程序内部的结构测试程序，检验程序中的每条通路是否都有能按预定要求正确工作，而不顾它的功能（programming skills--需要编程能力）。</p>\n<p>白盒测试常用方法： 基本覆盖标准：逻辑驱动、循环、基路测试等，主要用于软件验证。</p>\n<p>“白盒”法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。</p>\n<p>“白盒”法是穷举路径测试。在使用这一方案时，测试者必须检查程序的内部结构，从检查程序的逻辑着手，得出测试数据。贯穿程序的独立路径数是天文数字。但即使每条路径都测试了仍然可能有错误,原因：</p>\n<ol>\n<li>第一，穷举路径测试决不能查出程序违反了设计规范，即程序本身是个错误的程序。</li>\n<li>第二，穷举路径测试不可能查出程序中因遗漏路径而出错。</li>\n<li>第三，穷举路径测试可能发现不了一些与数据相关的错误。</li>\n</ol>\n<p><img src=\"/images/white-box-path-list.png\" alt=\"白盒路径法\" loading=\"lazy\"></p>\n<h3 id=\"黑盒\" tabindex=\"-1\"> 黑盒</h3>\n<p><img src=\"/images/types-of-software-testing-black-box.png\" alt=\"黑盒测试\" loading=\"lazy\"></p>\n<p>也称功能测试、数据驱动测试，它将被测软件看作一个打不开的黑盒，主要根据功能需求设计测试用例，进行测试。</p>\n<p>概念：黑盒测试是从一种从软件外部对软件实施的测试，也称功能测试或基于规格说明的测试。</p>\n<p>其基本观点是：任何程序都可以看作是从输入定义域到输出值域的映射，这种观点将被测程序看作一个打不开的黑盒，黑盒里面的内容(实现)是完全不知道的，只知道软件要做什么。</p>\n<p>因无法看到盒子中的内容，所以不知道软件是如何实现的，也不关心黑盒里面的结构，只关心软件的输入数据和输出结果。</p>\n<h4 id=\"功能性\" tabindex=\"-1\"> 功能性</h4>\n<p><img src=\"/images/types-of-software-testing-function.png\" alt=\"测试功能性测试\" loading=\"lazy\"></p>\n<ol>\n<li>单元</li>\n<li>回归</li>\n<li>集成</li>\n<li>冒烟</li>\n<li>黑白盒</li>\n<li>数据库</li>\n<li>静态测试</li>\n</ol>\n<p><img src=\"/images/function_test_pic.png\" alt=\"功能性测试种类\" loading=\"lazy\"></p>\n<p><strong>静态测试</strong> 所谓静态测试(Static testing)就是不实际运行被测软件，而只是静态地检查程序代码、界面或文档中可能存在的错误的过程。</p>\n<p>这个类似我们的代码审查(code review), 或者文档功能审查，成本比较低。 带来的好处：</p>\n<ol>\n<li>It produces a defect-free product.     减少产品缺陷</li>\n<li>It ensures that the customer is satisfied.  保证客户需求</li>\n<li>It ensures that all requirements met.    需求实现充分</li>\n<li>It ensures security and safety.   安全保证</li>\n<li>It improves the quality of the product. 质量</li>\n</ol>\n<h4 id=\"非功能性\" tabindex=\"-1\"> 非功能性</h4>\n<p>非功能测试是一种用于检查软件应用程序的非功能方面（性能，可用性，可靠性等）的测试。它旨在根据功能测试从未解决的非功能参数来测试系统的准备情况。</p>\n<p>非功能测试与功能测试同样重要，并影响客户满意度。</p>\n<p><img src=\"/images/types-of-software-testing-no-function.png\" alt=\"非功能测试\" loading=\"lazy\"></p>\n<ol>\n<li><strong>安全</strong>：该参数定义了如何保护系统免受来自内部和外部源的故意和突然攻击。这是通过安全测试测试的。</li>\n<li><strong>可靠性</strong>：任何软件系统在不失败的情况下连续执行指定功能的程度。这通过可靠性测试进行测试</li>\n<li><strong>生存能力</strong>：该参数检查软件系统是否继续运行并在系统出现故障时自行恢复。这由RecoveryTesting检查</li>\n<li><strong>可用性</strong>：该参数确定用户在操作期间可依赖系统的程度。这由StabilityTesting检查。</li>\n<li><strong>可用性</strong>：用户可以通过与系统的交互轻松学习，操作，准备输入和输出。这可以通过可用性测试来检查</li>\n<li><strong>可扩展性</strong>：该术语指的是任何软件应用程序可以扩展其处理能力以满足需求增长的程度。这是由可伸缩性测试测试的</li>\n<li><strong>互操作性</strong>：该非功能性参数检查软件系统与其他软件系统的接口。这由互操作性测试检查</li>\n<li><strong>效率</strong>：任何软件系统在多大程度上可以处理容量，数量和响应时间。</li>\n<li><strong>灵活性</strong>：该术语指的是应用程序在不同硬件和软件配置中的易用性。像最低RAM，CPU要求。</li>\n<li><strong>可移植性</strong>：软件从其当前硬件或软件环境转移的灵活性。</li>\n<li><strong>可重用性</strong>：它指的是可以转换为在另一个应用程序中使用的软件系统的一部分。</li>\n</ol>\n<h3 id=\"灰盒\" tabindex=\"-1\"> 灰盒</h3>\n<p>看完黑盒，白盒的差别，是否有中间状态？ 灰色？</p>\n<table>\n<thead>\n<tr>\n<th>白盒</th>\n<th>黑盒</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>The developers can perform white box testing.开发人员可以干</td>\n<td>The test engineers perform the black box testing. 测试人员</td>\n</tr>\n<tr>\n<td>To perform WBT, we should have an understanding of the programming languages. 需要懂代码</td>\n<td>To perform BBT, there is no need to have an understanding of the programming languages.不需要知道语言</td>\n</tr>\n<tr>\n<td>In this, we will look into the source code and test the logic of the code. 主要代码逻辑，安全，压力</td>\n<td>In this, we will verify the functionality of the application based on the requirement specification.基于应用本身和需求分析</td>\n</tr>\n<tr>\n<td>In this, the developer should know about the internal design of the code. 需要知道整体框架</td>\n<td>In this, there is no need to know about the internal design of the code.不需要知道内部代码</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/images/types-of-software-testing-gray.png\" alt=\"灰盒测试\" loading=\"lazy\"></p>\n<p>灰盒就是需要既对流程逻辑， 还要对内部的工作机制，也就是程序代码有所了解，也就是对灰盒测试的人员有更高的要求！</p>\n<p><img src=\"/images/greybox-testing-gray-detail.png\" alt=\"Reasons for GreyBox testing\" loading=\"lazy\"></p>\n<p>灵魂拷问， 如何更好的手动测试！</p>\n<ol>\n<li>First, tester observes all documents related to software, to select testing areas.     需要熟悉所有的文档</li>\n<li>Tester analyses requirement documents to cover all requirements stated by the customer.   需求分析的透彻了解， 了解用户的需求</li>\n<li>Tester develops the test cases according to the requirement document.      根据需求文档写测试用例</li>\n<li>All test cases are executed manually by using Black box testing and white box testing   所有测试用例测试通过</li>\n<li>If bugs occurred then the testing team informs the development team.          bug  及时反馈开发</li>\n<li>The Development team fixes bugs and handed software to the testing team for a retest.       回归测试</li>\n</ol>\n<p>当然还有最最重要的 <strong>自动测试</strong>， 后面会详细解释，注意这个和我们一般开发理解的 unit/integration 测试还不太一样。</p>\n<h2 id=\"自动测试\" tabindex=\"-1\"> 自动测试</h2>\n<p><img src=\"/images/types-of-software-testing16.png\" alt=\"auto test\" loading=\"lazy\"></p>\n<p>依赖一些自动化测试工具， 将测试的步骤和内容转换成脚本， 比如行业内工具：</p>\n<ol>\n<li>Selenium  浏览器自动测试工具</li>\n<li>Watir</li>\n<li>QTP</li>\n<li>Telerik Studio</li>\n<li>Testim</li>\n<li>Applitools</li>\n<li>JMeter</li>\n</ol>\n<p><img src=\"/images/automation-testing-tool.png\" alt=\"auto tool\" loading=\"lazy\"></p>\n<p>按照这个定义我们使用的 junit 等框架是否属于自动化测试工具？</p>\n",
      "image": "https://www.dearxue.com/web_html_tester/images/types-of-software-testing_detail.png",
      "date_published": "2022-06-23T07:11:29.000Z",
      "date_modified": "2022-06-28T00:13:32.000Z",
      "authors": [],
      "tags": [
        "测试"
      ]
    },
    {
      "title": "测试层级",
      "url": "https://www.dearxue.com/web_html_tester/theory/005_test_layer.html",
      "id": "https://www.dearxue.com/web_html_tester/theory/005_test_layer.html",
      "content_html": "<p>这里的测试自动化包括两个方面：</p>\n<ol>\n<li>开发人员</li>\n<li>QA 人员</li>\n</ol>\n<h2 id=\"层级\" tabindex=\"-1\"> 层级</h2>\n<p><img src=\"/images/levels-of-testing.png\" alt=\"测试层级\" loading=\"lazy\"></p>\n<ol>\n<li>单元测试 Unit Testing</li>\n<li>集成测试 Integration Testing</li>\n<li>系统测试 System Testing</li>\n<li>用户接受测试 Acceptance Testing</li>\n</ol>\n<h2 id=\"单元测试\" tabindex=\"-1\"> 单元测试</h2>\n<p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。至于“单元”的大小或范围，并没有一个明确的标准，“单元”可以是一个函数、方法、类、功能模块或者子系统。</p>\n<p>单元测试通常和白盒测试联系到一起，如果单从概念上来讲两者是有区别的，不过我们通常所说的“单元测试”和“白盒测试”都认为是和代码有关系的，所以在某些语境下也通常认为这两者是同一个东西。</p>\n<p>还有一种理解方式，单元测试和白盒测试就是对开发人员所编写的代码进行测试， 概念这个东西大概理解是什么意思即可。</p>\n<p>这个教程主要针对开发人员， 所以提前透露下， 你现在理解的单元测试没有那么复杂，就是你平时接触到的 比如java 世界里的 Junit, mockit, powermock 等等工具。</p>\n<h3 id=\"谁来做\" tabindex=\"-1\"> 谁来做</h3>\n<p>单元测试简单理解就是对开发人员所编写的代码进行测试，既然和代码相关我们第一感觉那应该是“开发人员来做”；</p>\n<p>再一看单元测试包含“测试”两个字，那么“测试人员来做”也应该是合理的吧。</p>\n<p>单元测试一般是有开发人员或测试人员来做。谁来做并没有一个绝对的标准，要根据公司的实际情况来决定。接下来我们分析一下开发人员或测试人员做单元测试的优缺点：</p>\n<p><strong>开发人员做单元测试：</strong></p>\n<p><strong>优点</strong>：开发人员对代码最熟悉，而且开发人员编程技能相对比较强，所以开发人员自己写单元测试效率上和覆盖率上都比较高\n<strong>缺点</strong>：开发人员平时写业务代码就要花费很多时间，有时候确实没有时间写单元测试；而且大部分开发人员没有太好的测试思想，单元测试可能只是写个最简单的用例就完了；自己写的代码自己测，往往都是不靠谱！</p>\n<p><strong>测试人员做单元测试：</strong></p>\n<p><strong>优点</strong>：测试人员有比较系统的测试思想，可以更好地保证用例的覆盖。而且通过写单测测试能更好地了解具体代码结构、流程，对于后续的业务测试也非常有利。\n<strong>缺点</strong>：测试人员的编程技能相对比较弱，如果不同编程是无法开展单元测试的。并且测试人员对代码没有开发人员熟悉，效率会比较低。</p>\n<h3 id=\"如何做\" tabindex=\"-1\"> 如何做</h3>\n<p>单元测试的实现方式包括：人工静态检查、动态执行跟踪</p>\n<p>人工静态检查：就是通常所说的“代码走读”，主要是保证代码逻辑的正确性\n动态执行跟踪：就是把程序代码运行起来，检查实际的运行结果和预期结果是否一致</p>\n<h4 id=\"人工静态检查\" tabindex=\"-1\"> 人工静态检查</h4>\n<p>人工静态检查包含的主要内容：</p>\n<ol>\n<li>检查算法的逻辑正确性</li>\n<li>模块接口的正确性检查</li>\n<li>输入参数有没有作正确性检查</li>\n<li>调用其他方法接口的正确性</li>\n<li>异常错误处理</li>\n<li>保证表达式、SQL语句的正确性</li>\n<li>检查常量或全局变量使用的正确性</li>\n<li>程序风格的一致性、规范性</li>\n<li>检查代码注释是否完整</li>\n</ol>\n<h4 id=\"动态执行跟踪\" tabindex=\"-1\"> 动态执行跟踪</h4>\n<p>动态执行跟踪需要编写测试脚本调用业务代码进行测试，为了更好的管理维护测试脚本，一般会采用单元测试框架来管理，不同的语言有不同的单元测试框架：</p>\n<ol>\n<li>Java：<code>JUnit</code>、TestNG</li>\n<li>Python：UintTest、pyTest</li>\n</ol>\n<p>单元测试的一个重要的衡量标准就是代码覆盖率，尽量做到代码的全覆盖。常见单元测试覆盖标准：</p>\n<ol>\n<li>语句覆盖</li>\n<li>分支覆盖</li>\n<li>条件覆盖</li>\n<li>分支-条件覆盖</li>\n<li>条件组合覆盖</li>\n<li>路径覆盖</li>\n</ol>\n<h2 id=\"集成测试\" tabindex=\"-1\"> 集成测试</h2>\n<p>集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。</p>\n<p><img src=\"/images/integration-testing.png\" alt=\"集成测试\" loading=\"lazy\"></p>\n<p>集成测试主要目的是测试模块之间的接口。 由于多种原因，仅单元测试是不够的，例如：</p>\n<ol>\n<li>模块/单元通常由单独的软件开发人员设计，其技术和编程逻辑与其他程序员不同</li>\n<li>通常在模块开发时，用户需求会发生变化，并且这些新需求可能未经过单元测试。这引发了问题</li>\n<li>在单元测试期间，有时会遗漏诸如数据格式，错误陷阱，硬件接口和第三方服务接口之类的问题</li>\n</ol>\n<p>因此，无论每个模块/单元的运行效率如何，如果它们未正确集成，都会影响软件程序的功能。</p>\n<p>集成测试目的：</p>\n<ol>\n<li>确保集成模块按预期正常工作</li>\n<li>它检测与模块之间的接口有关的错误</li>\n<li>帮助模块与API和其他第三方工具进行交互</li>\n<li>通常覆盖大量系统，因此效率更高</li>\n<li>增加测试范围并提高测试的可靠性</li>\n</ol>\n<h3 id=\"如何做集成测试\" tabindex=\"-1\"> 如何做集成测试</h3>\n<p>集成的含义非常简单–将经过单元测试的模块一个接一个地组合，然后测试组合单元的功能。</p>\n<p>通常，集成测试是在单元测试之后进行的。一旦创建并测试了所有单个单元，我们便开始组合那些经过测试的模块并开始执行集成测试：</p>\n<ol>\n<li>准备测试整合计划</li>\n<li>确定集成测试方法的类型</li>\n<li>相应地设计测试用例，测试场景和测试脚本</li>\n<li>一起部署所选模块并运行集成测试</li>\n<li>跟踪缺陷并记录测试结果</li>\n<li>重复上述步骤，直到测试完整个系统</li>\n</ol>\n<h3 id=\"集成测试的方法\" tabindex=\"-1\"> 集成测试的方法</h3>\n<p><img src=\"/images/integration-testing5.png\" alt=\"集成测试方法论\" loading=\"lazy\"></p>\n<h3 id=\"全量整合测试\" tabindex=\"-1\"> 全量整合测试</h3>\n<p><img src=\"/images/big-bang-method3.png\" alt=\"big bang\" loading=\"lazy\"></p>\n<p>在这种测试方法中，一旦所有模块分别开发和测试，它们将被集成一次并立即一起测试。这种测试的唯一优点是，它非常适合于较小的系统。</p>\n<p>缺点</p>\n<ol>\n<li>故障定位很困难</li>\n<li>测试之前有很多延迟</li>\n<li>关键问题没有得到优先解决</li>\n<li>很难找到问题的根本原因</li>\n</ol>\n<h3 id=\"增量集成测试\" tabindex=\"-1\"> 增量集成测试</h3>\n<p>通过将逻辑上相关的两个或更多模块连接在一起来执行增量测试。</p>\n<p>后来又添加了更多模块，并对其功能进行了测试。直到完成所有模块的集成并成功测试为止。</p>\n<p>它又分为自上而下方法，自下而上方法。</p>\n<h4 id=\"自上而下的集成测试\" tabindex=\"-1\"> 自上而下的集成测试</h4>\n<p>自上而下的方法从测试最顶层的模块开始，然后逐步地逐步降到最低的一组模块。</p>\n<p>测试按照软件系统的控制流程从上到下进行。由于在测试顶层模块时有可能未开发出较低级别的模块，因此我们使用存根而不是那些尚未就绪的模块。</p>\n<p>对于简单的应用程序，存根将简单地将控件返回其上级模块。对于复杂的应用程序，他们将模拟整个响应范围。</p>\n<p>优点</p>\n<ol>\n<li>故障定位更容易</li>\n<li>测试产品极为一致</li>\n<li>与驱动程序相比，可以以更少的时间写存根</li>\n<li>关键模块经过优先级测试</li>\n<li>尽早发现主要设计缺陷</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>需要几个存根</li>\n<li>对早期发布的支持不佳</li>\n<li>在周期结束时测试基本功能</li>\n</ol>\n<h4 id=\"自下而上的集成测试\" tabindex=\"-1\"> 自下而上的集成测试</h4>\n<p>自下而上的方法从测试应用程序的最低单元开始，然后逐步地逐步进行。</p>\n<p>从控制流的底部到向上进行测试。同样，在测试较低的模块时，可能尚未开发出较高级别的模块。</p>\n<p>在这种情况下，我们通过使用驱动程序来模拟缺少的模块的功能。这些驱动程序执行一系列任务，例如调用被测模块，传递测试数据或接收输出数据。</p>\n<p>优点</p>\n<ol>\n<li>在这里，开发和测试可以一起完成，从而使产品高效</li>\n<li>测试条件很容易创建</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>需要几个驱动程序</li>\n<li>数据流测试很晚</li>\n<li>需要驱动程序使测试数据管理变得复杂</li>\n<li>对早期发布的支持不佳</li>\n<li>关键接口缺陷发现较晚</li>\n</ol>\n<h2 id=\"系统测试\" tabindex=\"-1\"> 系统测试</h2>\n<p>系统测试包括测试完全集成的软件系统。通常，计算机系统是通过软件集成制成的。</p>\n<p>换句话说，一组软件的计算机系统执行各种任务，但只有软件才能执行任务; 软件必须与兼容的硬件接口。</p>\n<p>系统测试是一系列不同类型的有目的的测试行使和审查针对需求的集成软件的计算机系统的全部工作。</p>\n<ol>\n<li>测试包括外部外围设备在内的完全集成的应用程序，以检查组件之间以及整个系统之间如何交互。这也称为<strong>端到端测试</strong>方案。</li>\n<li>验证对应用程序中每个输入的全面测试，以检查所需的输出。</li>\n<li>测试用户对应用程序的体验。</li>\n</ol>\n<p><img src=\"/images/system-testing8.png\" alt=\"System testing role\" loading=\"lazy\"></p>\n<h2 id=\"uat-测试\" tabindex=\"-1\"> UAT 测试</h2>\n<p>UAT，(User Acceptance Test),也就是用户验收测试，或用户可接受测试,这时相关的用户或独立测试人员根据测试计划和结果对系统进行测试和接收。</p>\n<p>在产品上线前，我们需要对整个项目每个细节功能都测试一遍，以确认功能没有问题的前提下，才能上线推出市场给真正的用户使用；</p>\n<p>这个过程，也是产品上线前的必经阶段，少了这个环节，可能会发现上线后面临急需修复或者影响用户的体验的问题。</p>\n<p>系统测试和UAT测试的差别？</p>\n<ol>\n<li>系统测试：系统测试是在系统未交付使用制作方自行进行的测试，无用户参与。只有本方用户参与。</li>\n<li>UAT测试：是本方人员和用户方一起实行的测试。</li>\n</ol>\n<p><img src=\"/images/acceptance-testing3.png\" alt=\"UAT testing\" loading=\"lazy\"></p>\n<h3 id=\"步骤编辑\" tabindex=\"-1\"> 步骤编辑</h3>\n<blockquote>\n<p>百度百科， 比较全面</p>\n</blockquote>\n<ol>\n<li>用户培训手册准备（就是针对要进行UAT测试的对象，及要进行培训的用户，准备一些培训资料：一般是测试对象使用/功能手册及要培训的用户的个人资料等等：就跟教师上课进行备课差不多）</li>\n<li>测试脚本发放（如果你公司采用自动化测试，那么每一个功能或一个模块等都有对应的测试脚本，可以把这些测试脚本分发给特定的人员；如果采用手工测试，就要把详细描述一个功能或模块的文档分给相关人员（当然自动化测试也要分发）</li>\n<li>用户补充业务测试场景和测试数据（就是：请有代表性的一些最终用户根据实际应用环境及一些常用处理的数据，来给一些补充与建议，越贴近实际应用越好）</li>\n<li>顾问补充测试步骤（你可以请项目专家，测试经理，或专门的测试，开发等顾问对测试步骤进行补充）</li>\n<li>培训资料及测试脚本文档的确定与最终输出(一般到此，各种资料都基本确定，这时可以将它们进行打印，或形成特别的电子文档）</li>\n<li>测试策略的制定</li>\n<li>测试用户的确定（大体上从培训人员中选取，因为不是每个接受培训的人员都能有资格去测试的，这里你可以通过一些考核来实现人员的筛选等等）</li>\n<li>由专门的测试组织机构确定测试地点，并发出通知</li>\n<li>测试网络环境的搭建和保障（包括网络，系统，硬软件，包括一些case工具等）</li>\n<li>组织进行测试</li>\n<li>评审分析提交的问题（这就进入了一般bug处理过程，形成了一个循环）</li>\n</ol>\n<h3 id=\"成功关键\" tabindex=\"-1\"> 成功关键</h3>\n<ol>\n<li>培训的资料表述要准确全面，易懂等（这是理论基础）</li>\n<li>人员选择，要典型有代表性（用户基础）</li>\n<li>测试流程步骤（要周密）</li>\n<li>测试策略制定（确定一个适合测试对象及测试人员的测试策略）</li>\n<li>问题的表达与处理(因为测试者不是专业开发测试人员，对于问题的表达可能不能到位，或根本就不是那种问题，这就存在如何复现与转化问题等）</li>\n</ol>\n<p>所有的测试都是保证软件高质量的交付！</p>\n",
      "image": "https://www.dearxue.com/web_html_tester/images/levels-of-testing.png",
      "date_published": "2022-06-23T07:11:29.000Z",
      "date_modified": "2022-06-28T00:13:32.000Z",
      "authors": [],
      "tags": [
        "测试"
      ]
    },
    {
      "title": "测试原则(阿里)",
      "url": "https://www.dearxue.com/web_html_tester/theory/099_test_principle.html",
      "id": "https://www.dearxue.com/web_html_tester/theory/099_test_principle.html",
      "content_html": "<p>参考： <strong>&lt;&lt;阿里测试手册&gt;&gt;</strong></p>\n<h2 id=\"【强制】好的单元测试必须遵守-air-原则\" tabindex=\"-1\"> 【强制】好的单元测试必须遵守 AIR 原则</h2>\n<p>说明：单元测试在线上运行时，感觉像空气（AIR）一样感觉不到，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</p>\n<p>A：Automatic（自动化）\nI：Independent（独立性）\nR：Repeatable（可重复）</p>\n<h2 id=\"【强制】单元测试应该是全自动执行的-并且非交互式的\" tabindex=\"-1\"> 【强制】单元测试应该是全自动执行的，并且非交互式的</h2>\n<p>测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元</p>\n<p>测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</p>\n<h2 id=\"【强制】保持单元测试的独立性\" tabindex=\"-1\"> 【强制】保持单元测试的独立性</h2>\n<p>为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</p>\n<p>反例：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。</p>\n<h2 id=\"【强制】单元测试是可以重复执行的-不能受到外界环境的影响\" tabindex=\"-1\"> 【强制】单元测试是可以重复执行的，不能受到外界环境的影响</h2>\n<p>说明：单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如果单测对外部</p>\n<p>环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。</p>\n<p>正例：为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring 这样的 DI</p>\n<p>框架注入一个本地（内存）实现或者 Mock 实现。</p>\n<h2 id=\"【强制】对于单元测试-要保证测试粒度足够小-有助于精确定位问题。\" tabindex=\"-1\"> 【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。</h2>\n<p>单测粒度至多是类级别，一般是方法级别。</p>\n<p>说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，</p>\n<p>那是集成测试的领域。</p>\n<h2 id=\"【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过\" tabindex=\"-1\"> 【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过</h2>\n<p>说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。</p>\n<h2 id=\"【强制】单元测试代码必须写在如下工程目录-src-test-java-不允许写在业务代码目录下\" tabindex=\"-1\"> 【强制】单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下</h2>\n<p>说明：源码编译时会跳过此目录，而单元测试框架默认是扫描此目录。</p>\n<h2 id=\"【推荐】单元测试的基本目标-语句覆盖率达到-70-核心模块的语句覆盖率和分支覆盖率都要达到-100\" tabindex=\"-1\"> 【推荐】单元测试的基本目标：语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率都要达到 100%</h2>\n<p>说明：在工程规约的应用分层中提到的 DAO 层，Manager 层，可重用度高的 Service，都应该进行单元测试。</p>\n<h2 id=\"【推荐】编写单元测试代码遵守-bcde-原则-以保证被测试模块的交付质量\" tabindex=\"-1\"> 【推荐】编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量</h2>\n<ol>\n<li>B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li>\n<li>C：Correct，正确的输入，并得到预期的结果。</li>\n<li>D：Design，与设计文档相结合，来编写单元测试。</li>\n<li>E：Error，强制错误信息输入（如：非法数据、异常流程、业务允许外等），并得到预期的结果。</li>\n</ol>\n<h2 id=\"【推荐】对于数据库相关的查询-更新-删除等操作规范\" tabindex=\"-1\"> 【推荐】对于数据库相关的查询，更新，删除等操作规范</h2>\n<p>不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。</p>\n<p>反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数</p>\n<p>据并不符合业务插入规则，导致测试结果异常。</p>\n<h2 id=\"【推荐】和数据库相关的单元测试-可以设定自动回滚机制-不给数据库造成脏数据。\" tabindex=\"-1\"> 【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。</h2>\n<p>或者对单元测试产生的数据有明确的前后缀标识。</p>\n<p>正例：在阿里巴巴企业智能事业部的内部单元测试中，使用 <code>ENTERPRISE_INTELLIGENCE _UNIT_TEST_</code> 的前缀来标识单元测试相关代码。</p>\n<h2 id=\"【推荐】对于不可测的代码在适当的时机做必要的重构-使代码变得可测\" tabindex=\"-1\"> 【推荐】对于不可测的代码在适当的时机做必要的重构，使代码变得可测</h2>\n<p>避免为了达到测试要求而书写不规范测试代码。</p>\n<h2 id=\"【推荐】在设计评审阶段-开发人员需要和测试人员一起确定单元测试范围\" tabindex=\"-1\"> 【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围</h2>\n<p>单元测试最好覆盖所有测试用例（UC）。</p>\n<h2 id=\"【推荐】单元测试作为一种质量保障手段-在项目提测前完成单元测试\" tabindex=\"-1\"> 【推荐】单元测试作为一种质量保障手段，在项目提测前完成单元测试</h2>\n<p>不建议项目发布后补充单元测试用例。</p>\n<h2 id=\"【参考】为了更方便地进行单元测试-业务代码应避免以下情况\" tabindex=\"-1\"> 【参考】为了更方便地进行单元测试，业务代码应避免以下情况</h2>\n<ol>\n<li>构造方法中做的事情过多。</li>\n<li>存在过多的全局变量和静态方法。</li>\n<li>存在过多的外部依赖。</li>\n<li>存在过多的条件语句。</li>\n</ol>\n<p>说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。</p>\n<h2 id=\"【参考】不要对单元测试存在如下误解\" tabindex=\"-1\"> 【参考】不要对单元测试存在如下误解</h2>\n<ol>\n<li>那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。</li>\n<li>单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。</li>\n<li>单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。</li>\n<li>单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。</li>\n</ol>\n",
      "date_published": "2022-06-23T07:11:29.000Z",
      "date_modified": "2022-06-28T00:04:39.000Z",
      "authors": [],
      "tags": [
        "测试"
      ]
    },
    {
      "title": "关于测试",
      "url": "https://www.dearxue.com/web_html_tester/theory/",
      "id": "https://www.dearxue.com/web_html_tester/theory/",
      "content_html": "<h2 id=\"写在前面\" tabindex=\"-1\"> 写在前面</h2>\n<p>在进行下一章节前可以问问自己这几个问题：</p>\n<ol>\n<li>什么是软件测试？</li>\n<li>开发人员和软件测试是否有关？还是只有QA组同学彩盒测试有关？</li>\n<li>写过测试？</li>\n<li>传统行业如何进行质量保证？</li>\n<li>测试重要否？</li>\n<li>测试是否耽误事？</li>\n</ol>\n",
      "date_published": "2022-06-23T07:11:29.000Z",
      "date_modified": "2022-06-23T07:11:29.000Z",
      "authors": [],
      "tags": [
        "测试"
      ]
    }
  ]
}